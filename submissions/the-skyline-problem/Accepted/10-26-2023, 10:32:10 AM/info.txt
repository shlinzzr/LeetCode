{"id":1084265844,"question_id":218,"lang":"java","lang_name":"Java","time":"7 months, 3 weeks","timestamp":1698287530,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1084265844/","is_pending":"Not Pending","title":"The Skyline Problem","memory":"46.6 MB","code":"\nclass Solution {\n\n    //https://www.youtube.com/watch?v=tQiXaCT0ndE\n\n    /*\n    几个想法：1. 其实这里的treemap只是用来对起始结束events排序的，应该可以直接用数组排序，省去treemap的overhead。2. 这里还是要对heap进行删除操作，Java的PriorityQueue实现的remove是O(n)的。我们可以改用treemap代替PriorityQueue或者不进行remove，标记一下就可以了，poll()的时候特殊处理一下。\n    */\n\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        TreeMap<Integer, List<int[]>> map = new TreeMap<>(); // Map<x, List<building>\n        for (int[] b : buildings) {\n            map.putIfAbsent(b[0], new ArrayList<>());\n            map.putIfAbsent(b[1], new ArrayList<>());\n            map.get(b[0]).add(b);\n            map.get(b[1]).add(b);\n        }\n\n        //max heap sort by height\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[2] - a[2]);\n\n        List<List<Integer>> res = new ArrayList<>();\n        \n        for (int x : map.keySet()) { // x-axis from left to right\n            List<int[]> list = map.get(x);\n            for (int[] b : list) {\n                if (b[0] == x) { // left\n                    maxHeap.offer(b);\n\n                } else { //right\n                    maxHeap.remove(b); // remove point when meet right\n                }\n            }\n            \n            if (maxHeap.size() == 0) { // if just meet right and remove, heap maybe 0, add additional bottom line which height is zero\n                res.add(Arrays.asList(x, 0));\n\n            } else {\n                int maxHeight = maxHeap.peek()[2];  // curr maxheight\n                \n                // prev point of height is not equal maxHeight means the maxHeight is change , need add res\n                // if \"First\" or  \"maxheight change\"\n                if (res.size() == 0 || res.get(res.size() - 1).get(1) != maxHeight) {\n                    res.add(Arrays.asList(x, maxHeight));\n                }\n            }\n        }\n        \n        return res;\n    }\n}\n\n         \n// class Solution {\n//     public List<List<Integer>> getSkyline(int[][] buildings) {\n//         List<List<Integer>> result = new ArrayList<>();\n//         List<int[]> height = new ArrayList<>();  // List<x, height> sort by x\n//         for(int[] b:buildings) { \n//             height.add(new int[]{b[0], -b[2]}); // left, -height\n//             height.add(new int[]{b[1], b[2]});  // right, height\n//         }\n//         Collections.sort(height, (a, b) -> {\n//                 if(a[0] != b[0]) \n//                     return a[0] - b[0];\n//                 return a[1] - b[1];\n//         });\n//         Queue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\n//         pq.offer(0);\n//         int prev = 0;\n//         for(int[] h:height) {\n//             if(h[1] < 0) {\n//                 pq.offer(-h[1]);\n//             } else {\n//                 pq.remove(h[1]);\n//             }\n//             int cur = pq.peek();\n//             if(prev != cur) {\n//                 List<Integer> list = new ArrayList<>();\n//                 list.add(h[0]);\n//                 list.add(cur);\n//                 result.add(list);\n//                 prev = cur;\n//             }\n//         }\n//         return result;\n//     }\n// }","compare_result":"11111111111111111111111111111111111111111","title_slug":"the-skyline-problem","has_notes":false,"flag_type":1}