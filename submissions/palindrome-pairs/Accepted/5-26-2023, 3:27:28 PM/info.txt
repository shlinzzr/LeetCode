{"id":957549921,"question_id":336,"lang":"java","lang_name":"Java","time":"1Â year","timestamp":1685086048,"status":10,"status_display":"Accepted","runtime":"153 ms","url":"/submissions/detail/957549921/","is_pending":"Not Pending","title":"Palindrome Pairs","memory":"55.4 MB","code":"class Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        HashMap<String, Integer> wordMap = new HashMap<>(); // word, index\n        Set<Integer> set = new TreeSet<>();\n        int n = words.length;\n        for(int i=0;i<n;i++){\n            wordMap.put(words[i],i);\n            set.add(words[i].length());\n        }\n        \n        List<List<Integer>> res = new ArrayList<>();\n        \n        for(int i=0;i<n;i++){\n            int wLen = words[i].length();\n            \n            if(wLen ==1){ //case 0: wLen==1 and contains empty string\n                if(wordMap.containsKey(\"\")){\n                    res.add(Arrays.asList(i, wordMap.get(\"\")));\n                    res.add(Arrays.asList(wordMap.get(\"\"), i));\n                }\n                continue;\n            }\n            \n            // case 1: got reverse prefect match\n            String reverse= new StringBuilder(words[i]).reverse().toString();\n            if(wordMap.containsKey(reverse) && wordMap.get(reverse) != i)\n                res.add(Arrays.asList(i,wordMap.get(reverse)));\n            \n\n            for(Integer k : set){\n                // means next strings will be larger than current one\n                //hence no prefix suffix would be possible\n                if(k == wLen) break;\n                \n                //find prefix      \n                //current string = sssll  ==> when k==3, need to find 'lls' & and check 'ss' isPalindrome;\n                //reverse string = lls'ss'\n                //we are checking if 'ss' is an palindrome\n                \n                if(isPalindrome(reverse, k, wLen-1)){\n                    String sub = reverse.substring(0, k); // lls \n                    //there should be an string: sss in map\n                    if(wordMap.containsKey(sub)){\n                        res.add(Arrays.asList(wordMap.get(sub), i));\n                    }\n                    \n                    //  if(\"lls\".equals(words[i])){\n                    //     System.out.println(reverse.substring(wLen-k));\n                    //     System.out.println(wordMap.containsKey(sub));\n                    // }\n                }\n                \n                //find suffix  e.g k==3  \n                //current string= sssll  // e.g. finding 'sss' and check 'll' isPalindrome\n                //reverse string= ll'sss'\n                //'ll' should be an palindrome\n                if(isPalindrome(reverse,0,wLen-1-k)){ // isPalindrome(\"sll\".sub(0,1))==true\n                    String sub = reverse.substring(wLen-k);\n                    if(wordMap.containsKey(sub)){\n                        res.add(Arrays.asList(i,wordMap.get(sub)));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    \n    private boolean isPalindrome(String s, int left, int right){\n        while(left<right)\n            if(s.charAt(left++)!=s.charAt(right--))\n                return false;\n        return true;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-pairs","has_notes":false,"flag_type":1}