{"id":1099081444,"question_id":2419,"lang":"java","lang_name":"Java","time":"7Â months","timestamp":1700016609,"status":10,"status_display":"Accepted","runtime":"138 ms","url":"/submissions/detail/1099081444/","is_pending":"Not Pending","title":"Subarray With Elements Greater Than Varying Threshold","memory":"58.1 MB","code":"class Solution {\n    public int validSubarraySize(int[] nums, int threshold) {\n        int len = nums.length;\n\n        int[] nextSmaller = new int[len];\n        Stack<Integer> st = new Stack<>();\n        Arrays.fill(nextSmaller, len);\n\n        for(int i=0; i<len; i++){\n            while(!st.isEmpty() && nums[st.peek()]>nums[i]){\n                nextSmaller[st.pop()] = i;\n            }\n            st.push(i);\n        }\n\n        int[] prevSmaller = new int[len];\n        Arrays.fill(prevSmaller, -1);\n        st.clear();\n        for(int i=len-1; i>=0; i--){\n            while(!st.isEmpty() && nums[st.peek()]>nums[i]){\n                prevSmaller[st.pop()] = i;\n            }\n            st.push(i);\n        }\n\n        for(int i=0; i<len; i++){\n\n            int area = (nextSmaller[i]-prevSmaller[i]-1)*nums[i];\n            if(area>threshold)\n                return nextSmaller[i]-prevSmaller[i]-1;\n        }\n\n        return -1;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subarray-with-elements-greater-than-varying-threshold","has_notes":false,"flag_type":1}