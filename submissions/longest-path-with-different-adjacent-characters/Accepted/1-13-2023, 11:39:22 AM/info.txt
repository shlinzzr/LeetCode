{"id":877184995,"question_id":2364,"lang":"java","lang_name":"Java","time":"1 year, 5 months","timestamp":1673581162,"status":10,"status_display":"Accepted","runtime":"144 ms","url":"/submissions/detail/877184995/","is_pending":"Not Pending","title":"Longest Path With Different Adjacent Characters","memory":"129.6 MB","code":"class Solution {\n    int res;\n    public int longestPath(int[] parent, String s) {\n        res = 0;\n        ArrayList<Integer>[] children = new ArrayList[parent.length];\n        for (int i = 0; i < parent.length; i++)\n            children[i] = new ArrayList<>();\n        for (int i = 1; i < parent.length; i++)\n            children[parent[i]].add(i);\n        dfs(children, s, 0);\n        return res;\n    }\n\n    private int dfs(ArrayList<Integer>[] children, String s, int i) {  // return the longest path to leaf\n        PriorityQueue<Integer> queue = new PriorityQueue<>(\n            (a,b) -> Integer.compare(b,a)\n        );\n        for (int j : children[i]) { // loop all children, find the longest path to leaf\n            int cur = dfs(children, s, j);\n            if (s.charAt(j) != s.charAt(i))\n                queue.offer(cur);  // here to add \"-cur\" is beacause thats no need to change priorityQueue's comparator\n        }\n        int big1 = queue.isEmpty() ? 0 : queue.poll();\n        int big2 = queue.isEmpty() ? 0 : queue.poll();\n        res = Math.max(res, big1 + big2 + 1);  // check curr node whether is the longest path root\n        return big1 + 1;                       // return the longer path plus self node\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-path-with-different-adjacent-characters","has_notes":false,"flag_type":1}