{"id":1252762611,"question_id":744,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1715183247,"status":10,"status_display":"Accepted","runtime":"29 ms","url":"/submissions/detail/1252762611/","is_pending":"Not Pending","title":"Network Delay Time","memory":"48.2 MB","code":"/*\nStep 1: Create a Map of start and end nodes with weight\n        1 -> {2,1},{3,2}\n        2 -> {4,4},{5,5}\n        3 -> {5,3}\n        4 ->\n        5 ->\n\nStep 2: create a result array where we will keep track the minimum distance to rech end of the node from start node\n\nStep 3: Create a Queue and add starting position with it's weight and add it's reachable distance with increament of own't weight plus a weight require to reach at the end node from start node.\n        We keep adding and removing pairs from queue and updating result array as well.\n\nStep 4: find the maximum value from result array:\n\n*/\n\nclass Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        \n        //Step 1\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\n        \n        for(int[] time : times) {\n            int start = time[0];\n            int end = time[1];\n            int weight = time[2];\n            \n            map.putIfAbsent(start, new HashMap<>());\n            map.get(start).put(end, weight);\n        }\n        \n         // Step 2\n        int[] dis = new int[n+1]; // watch out the time is 1-idx\n        Arrays.fill(dis, Integer.MAX_VALUE);\n        dis[k] = 0;\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.add(new int[]{k,0}); // idx, currCost\n        \n        //Step 3:\n        while(!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int curNode = cur[0];\n            int curWeight = cur[1];\n            \n            for(int next : map.getOrDefault(curNode, new HashMap<>()).keySet()) {\n                int nextweight = map.get(curNode).get(next);\n                \n                if(curWeight + nextweight < dis[next]) {\n                    dis[next] = curWeight + nextweight;\n                    queue.add(new int[]{next, curWeight + nextweight});\n                }\n            }\n        }\n        \n        //Step 4:\n        int res = 0;\n        for(int i=1; i<=n; i++) {\n            res = Math.max(res, dis[i]);\n        }\n        \n        return res == Integer.MAX_VALUE ? -1 : res;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"network-delay-time","has_notes":false,"flag_type":1}