{"id":911989644,"question_id":1706,"lang":"java","lang_name":"Java","time":"1 year, 3 months","timestamp":1678353978,"status":10,"status_display":"Accepted","runtime":"109 ms","url":"/submissions/detail/911989644/","is_pending":"Not Pending","title":"Min Cost to Connect All Points","memory":"42.3 MB","code":"class Solution {\n    // Prim's  ref: https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/843972/Java-Minimum-Spanning-Tree%3A-Prim-%2B-Kruskal\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length, ans = 0;\n        HashSet<Integer> mst = new HashSet<>();\n        mst.add(0);\n        int[] dist = new int[n];\n        for(int i = 1; i < n; i++) dist[i] = findDist(points, 0, i);\n        while(mst.size() != n) {\n            // Find the node that has shortest distance\n            int next = -1;\n            for(int i = 0; i < n; i++) {\n                if(mst.contains(i)) continue;\n                if(next == -1 || dist[next] > dist[i]) next = i;\n            }\n            // Put the node into the Minning Spanning Tree\n            mst.add(next);\n            ans += dist[next];\n            // Update distance array\n            for(int i = 0; i < n; i++) {\n                if(!mst.contains(i)) {\n                    dist[i] = Math.min(dist[i], findDist(points, i, next));\n                }\n            }\n        }\n        return ans;\n    }\n    private int findDist(int[][] points, int a, int b) {\n        return Math.abs(points[a][0] - points[b][0]) + Math.abs(points[a][1] - points[b][1]);\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"min-cost-to-connect-all-points","has_notes":false,"flag_type":1}