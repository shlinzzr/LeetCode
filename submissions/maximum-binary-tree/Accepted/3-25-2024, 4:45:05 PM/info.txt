{"id":1213311374,"question_id":654,"lang":"java","lang_name":"Java","time":"2 months, 2 weeks","timestamp":1711356305,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1213311374/","is_pending":"Not Pending","title":"Maximum Binary Tree","memory":"44.6 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    /** \n        This problem has been asked in below companies:\n        Amazon\n        Microsoft\n\n    */\n\n    /** \n        The intuition is to use monotonic stack. \n        To maintain a decreasing order stack, in the decreasing order we will connect each node on the right of the\n        top element in stack.\n\n        Whenever we find a greater value we will start to pop element from stack and connect the popped element\n        on the left of the current element, we will be doing this process untill we found a grater element in the stack\n\n        once we are done with traversing the array, we need to return the most bottom element in the stack\n\n        Time complexity: O(n)\n        Space complexity: O(n)\n\n    */\n\n\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n\n        // to store the node in decreasing order\n        Stack<TreeNode> stack = new Stack<>();\n\n        // traverse the array\n        for(int num : nums) {\n            // create a new node\n            TreeNode node = new TreeNode(num);\n\n            // 想法: stack大的壓到下面, 最後pop出來給curr當左子樹 \n            // 只要curr > stack.top 就 pop, 此時stack呈現降序(愈新的愈小, 愈pop愈大)\n            // st之前都是prefix 左邊子樹 curr.left = st.pop();\n            \n            // check the stack is not empty and current element is greater than \n            // the top element in the stack \n            // if yes then pop the node and connect to the right of the current node\n            \n            //找左子樹\n            while(!stack.isEmpty() && stack.peek().val < num) {\n                node.left = stack.pop();\n            }\n\n            // if the stack is not empty\n            // meaning the current element is less than the top element in the stack\n            // so connect the curre node in the right of the top element node in the stack\n\n            //如果已經盡量pop掉了 stack還是有剩, 表示stack.top>curr => stack.top.right = curr; (接下來的都是postfix 右邊子樹)\n            if(!stack.isEmpty()) stack.peek().right = node;\n\n            // add the current node in the stack\n            stack.push(node);\n        }\n\n        // return the most bottom element in the stack\n        return stack.firstElement();\n        \n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-binary-tree","has_notes":false,"flag_type":1}