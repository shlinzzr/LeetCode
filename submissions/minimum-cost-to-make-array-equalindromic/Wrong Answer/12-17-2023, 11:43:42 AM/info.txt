{"id":1121491153,"question_id":3229,"lang":"java","lang_name":"Java","time":"5 months, 4 weeks","timestamp":1702784622,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1121491153/","is_pending":"Not Pending","title":"Minimum Cost to Make Array Equalindromic","memory":"N/A","code":"class Solution {\n    public long minimumCost(int[] nums) {\n        \n        long cost = 0; // Math.abs(n-x);\n        int len = nums.length;\n        \n        int sum = 0;\n        \n        for(int i=0; i<len; i++){\n            sum += nums[i];\n        }\n        \n        if(isPal(sum/len)){\n            for(int i=0; i<len ; i++){\n                cost+=Math.abs(nums[i]-sum/len);\n            }\n            return cost;\n        }\n        \n        \n        \n        String[] rt = nearestPalindromic(String.valueOf(sum/len));\n        \n        Integer mid = Integer.valueOf(rt[0]);\n   \n        for(int i=0; i<len ; i++){\n             cost+=Math.abs(nums[i]-mid);\n        }\n        \n        if(sum/len>=1 && sum/len<=9){\n             long cost2=0;\n            int mid2 = mid+1;\n            for(int i=0; i<len ; i++){\n                 cost2+=Math.abs(nums[i]-mid2);\n            }\n\n            return Math.min(cost, cost2);\n        }\n        \n        \n        if(rt.length>1){\n            long cost2=0;\n            Integer mid2 = Integer.valueOf(rt[1]);\n   \n            for(int i=0; i<len ; i++){\n                 cost2+=Math.abs(nums[i]-mid2);\n            }\n\n            return Math.min(cost, cost2);\n        }\n        \n        return cost;\n        \n        \n       \n        \n        \n        \n        //chose a n\n        // 1 2 2 3 => 2\n        // 11 11 11 99 99 99=>  11:88 +88 + ,   55:44+44+44+ 44+44\n        \n        // 12 12 12 99 99 99\n        \n//         PriorityQueue<int[]> pq= new ArrayList<>(\n//             (a,b) -> b[0]==a[0] ? b[1]-a[1] ? b[0]-a[0] \n//         );\n        \n//         Arrays.sort(nums);\n//          HashMap<Integer, Integer> imap = new HashMap<>();\n//         HashMap<Integer, Integer> map = new HashMap<>();\n        \n//         for(int i=0; i<len; i++){\n//             map.put(nums[i], map.getOrDefault(nums[i],0)+1);\n//             imap.put(nums[i], i);\n//         }\n        \n//         for(Integer k : map.keySet()){\n//             pq.offer(new int[]{map.get(k), imap.get(k), k});\n//         }\n        \n//         while(!pq.isEmpty()){\n            \n            \n//         }\n        \n//         int[] p = pq.poll();\n        \n//         for(int i=0; i<len; i++){\n//             cost+=Math.abs(nums[i]-p[2]);\n//         }\n        \n        \n//         return cost;\n        \n         \n        \n    }\n    \n    \n    private boolean isPal(int n){\n        int tmp = n;\n        int rev = 0;\n        while(tmp>0){\n            rev*=10;\n            rev+=tmp%10;\n            tmp/=10;\n        }\n        \n        return rev==n;\n    }\n    \n    public String[] nearestPalindromic(String n) {\n        long nl = Long.parseLong(n);\n        int len = n.length();\n        \n        // if(len==1 || isPal(Integer.valueOf(n))) return n;\n         \n        //\n        // Corner cases\n        //\n        \n        // <= 10 or equal to 100, 1000, 10000, ... \n        if (nl <= 10 || (nl % 10 == 0 \n                         && n.charAt(0)=='1'\n                         && Long.parseLong(n.substring(1)) == 0)) {\n            \n            return new String[]{\"\" + (nl - 1)};\n        }\n        \n        // 11 or 101, 1001, 10001, 100001, ... \n        if (nl == 11 || (nl % 10 == 1 \n                         && n.charAt(0) == '1' \n                         && Long.parseLong(n.substring(1, len - 1)) == 0)) {\n           return new String[]{\"\" + (nl - 2)};\n        }\n        \n        // 99, 999, 9999, 99999, ...  \n        if (isAllDigitNine(n)) {\n            return new String[]{\"\" + (nl +2 )};\n        }\n        \n        //\n        // Construct the closest palindrome and calculate absolute difference with n\n        //\n        boolean isEvenDigits = len % 2 == 0;\n        \n        String palindromeRootStr\n            = (isEvenDigits) ? n.substring(0, len / 2) : n.substring(0, len / 2 + 1);\n        \n        int palindromeRoot = Integer.valueOf(palindromeRootStr); \n        long equal = toPalindromeDigits(\"\" + palindromeRoot, isEvenDigits);\n        long diffEqual = Math.abs(nl - equal);\n            \n        long bigger = toPalindromeDigits(\"\" + (palindromeRoot + 1), isEvenDigits);\n        long diffBigger = Math.abs(nl - bigger);\n        \n        long smaller = toPalindromeDigits(\"\" + (palindromeRoot - 1), isEvenDigits);\n        long diffSmaller = Math.abs(nl - smaller);\n         \n         \n        //\n        // Find the palindrome with minimum absolute differences\n        // If tie, return the smaller one\n        //\n        long closest = (diffBigger < diffSmaller) ? bigger : smaller;\n        long minDiff = Math.min(diffBigger, diffSmaller);\n        \n        // if (diffEqual != 0) { // n is not a palindrome, diffEqual should be considered\n        //     if (diffEqual == minDiff) { // if tie\n        //         closest = Math.min(equal, closest);\n        //     } else if (diffEqual < minDiff){\n        //         closest = equal;\n        //     }\n        // }\n        \n        return new String[]{ \"\"+Math.min(equal, closest), \"\"+equal};\n    }\n    \n    private long toPalindromeDigits(String num, boolean isEvenDigits) {\n        StringBuilder reversedNum = new StringBuilder(num).reverse();\n        String palindromeDigits = isEvenDigits\n            ? num + reversedNum.toString()\n            : num + (reversedNum.deleteCharAt(0)).toString();\n        return Long.parseLong(palindromeDigits);\n    }\n    \n    private boolean isAllDigitNine(String n) {\n        for (char ch : n.toCharArray()) {\n            if (ch != '9') {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // 10+9+6+3+13 111-> 109\n    // 8+7+4+1+15\n}","compare_result":"111111111111111111110111100111111111101111111110111011110000001000101011100001101010010111111101011111011110111111011100011011001111011111101111101111110111100111111111100010111011010011101011111011110000111111111111110010011110110011000101011101001011011100010001011111110111001010111010000000000000000101100001110000000001000010001000001000000000011100100001000001100000000000000100000000111010000000001000010001100010001000011100101010000010000001000001011000001011011001100100000100000000010100100011110100100100100000100001011111110001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"minimum-cost-to-make-array-equalindromic","has_notes":false,"flag_type":1}