{"id":1121470734,"question_id":3229,"lang":"java","lang_name":"Java","time":"5 months, 4 weeks","timestamp":1702783418,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1121470734/","is_pending":"Not Pending","title":"Minimum Cost to Make Array Equalindromic","memory":"N/A","code":"class Solution {\n    public long minimumCost(int[] nums) {\n        \n        long cost = 0; // Math.abs(n-x);\n        int len = nums.length;\n        \n        int sum = 0;\n        \n        for(int i=0; i<len; i++){\n            sum += nums[i];\n        }\n        \n        String rt = nearestPalindromic(String.valueOf(sum/len));\n        \n        System.out.println(rt);\n        Integer mid = Integer.valueOf(rt);\n        \n        for(int i=0; i<len ; i++){\n             cost+=Math.abs(nums[i]-mid);\n        }\n        \n        return cost;\n        \n        \n        \n        //chose a n\n        // 1 2 2 3 => 2\n        // 11 11 11 99 99 99=>  11:88 +88 + ,   55:44+44+44+ 44+44\n        \n        // 12 12 12 99 99 99\n        \n//         PriorityQueue<int[]> pq= new ArrayList<>(\n//             (a,b) -> b[0]==a[0] ? b[1]-a[1] ? b[0]-a[0] \n//         );\n        \n//         Arrays.sort(nums);\n//          HashMap<Integer, Integer> imap = new HashMap<>();\n//         HashMap<Integer, Integer> map = new HashMap<>();\n        \n//         for(int i=0; i<len; i++){\n//             map.put(nums[i], map.getOrDefault(nums[i],0)+1);\n//             imap.put(nums[i], i);\n//         }\n        \n//         for(Integer k : map.keySet()){\n//             pq.offer(new int[]{map.get(k), imap.get(k), k});\n//         }\n        \n//         while(!pq.isEmpty()){\n            \n            \n//         }\n        \n//         int[] p = pq.poll();\n        \n//         for(int i=0; i<len; i++){\n//             cost+=Math.abs(nums[i]-p[2]);\n//         }\n        \n        \n//         return cost;\n        \n         \n        \n    }\n    \n    \n    private boolean isPal(int n){\n        int tmp = n;\n        int rev = 0;\n        while(tmp>0){\n            rev*=10;\n            rev+=tmp%10;\n            tmp/=10;\n        }\n        \n        return rev==n;\n    }\n    \n    public String nearestPalindromic(String n) {\n        long nl = Long.parseLong(n);\n        int len = n.length();\n        \n        if(len==1) return n;\n         \n        //\n        // Corner cases\n        //\n        \n        // <= 10 or equal to 100, 1000, 10000, ... \n        if (nl <= 10 || (nl % 10 == 0 \n                         && n.charAt(0)=='1'\n                         && Long.parseLong(n.substring(1)) == 0)) {\n            \n            return \"\" + (nl - 1);\n        }\n        \n        // 11 or 101, 1001, 10001, 100001, ... \n        if (nl == 11 || (nl % 10 == 1 \n                         && n.charAt(0) == '1' \n                         && Long.parseLong(n.substring(1, len - 1)) == 0)) {\n            return \"\" + (nl - 2);\n        }\n        \n        // 99, 999, 9999, 99999, ...  \n        if (isAllDigitNine(n)) {\n            return \"\" + (nl + 2);\n        }\n        \n        //\n        // Construct the closest palindrome and calculate absolute difference with n\n        //\n        boolean isEvenDigits = len % 2 == 0;\n        \n        String palindromeRootStr\n            = (isEvenDigits) ? n.substring(0, len / 2) : n.substring(0, len / 2 + 1);\n        \n        int palindromeRoot = Integer.valueOf(palindromeRootStr); \n        long equal = toPalindromeDigits(\"\" + palindromeRoot, isEvenDigits);\n        long diffEqual = Math.abs(nl - equal);\n            \n        long bigger = toPalindromeDigits(\"\" + (palindromeRoot + 1), isEvenDigits);\n        long diffBigger = Math.abs(nl - bigger);\n        \n        long smaller = toPalindromeDigits(\"\" + (palindromeRoot - 1), isEvenDigits);\n        long diffSmaller = Math.abs(nl - smaller);\n         \n         \n        //\n        // Find the palindrome with minimum absolute differences\n        // If tie, return the smaller one\n        //\n        long closest = (diffBigger < diffSmaller) ? bigger : smaller;\n        long minDiff = Math.min(diffBigger, diffSmaller);\n        \n        if (diffEqual != 0) { // n is not a palindrome, diffEqual should be considered\n            if (diffEqual == minDiff) { // if tie\n                closest = Math.min(equal, closest);\n            } else if (diffEqual < minDiff){\n                closest = equal;\n            }\n        }\n        \n        return \"\" + closest;\n    }\n    \n    private long toPalindromeDigits(String num, boolean isEvenDigits) {\n        StringBuilder reversedNum = new StringBuilder(num).reverse();\n        String palindromeDigits = isEvenDigits\n            ? num + reversedNum.toString()\n            : num + (reversedNum.deleteCharAt(0)).toString();\n        return Long.parseLong(palindromeDigits);\n    }\n    \n    private boolean isAllDigitNine(String n) {\n        for (char ch : n.toCharArray()) {\n            if (ch != '9') {\n                return false;\n            }\n        }\n        return true;\n    }\n}","compare_result":"111111111111111111110111100111111100111111011110111001111110111101101011110111111101111000000011111011011100111111111100000011001111010110110101111110100111000011011111101110101011010010111011011011110001111011011111111111111110010111011101111111111011111111110011110111111111111111001010000000000000000101100001110000000001000010001000000000000000010100100001000001100000000000000000000000110010000000001000000001000010000000011100101010000010000001000001111000001010011000100100000100000000000100100010110100000100100000100001000111100001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"minimum-cost-to-make-array-equalindromic","has_notes":false,"flag_type":1}