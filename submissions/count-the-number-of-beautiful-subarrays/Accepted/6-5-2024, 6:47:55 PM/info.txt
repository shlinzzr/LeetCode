{"id":1278366647,"question_id":2656,"lang":"java","lang_name":"Java","time":"1 week","timestamp":1717584475,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/1278366647/","is_pending":"Not Pending","title":"Count the Number of Beautiful Subarrays","memory":"62.5 MB","code":"class Solution {\n    public long beautifulSubarrays(int[] nums) {\n\n        // 10^6 == 2^20\n    //     // 1. sliding window\n    //     // 2. presum + hashmap\n    // 分開看的話就是 走到k的時候loop i , j 找到滿足下面條件\n    // 但是nums.length==10^5,因此O(n^2)不可能\n    //     2*presum[j]-presum[i-1] == presum[k]\n    //          i     j.       k   \n    //  xxx  |  x     x    x   x | x x x\n    //        0100 0010   0110\n    //     a. k=0100\n    //     b. k=0010\n\n    //     presum :\n    //     0100 0110 0110\n\n\n        // 翻譯: 找出一個subarray 他的每個bit==1個數相加起來是偶數 (才有可能i j同時減掉)\n        // 用state 紀錄 **********01  req : 出現偶數次1\n        \n        HashMap<Long, Integer> map = new HashMap<>(); // state, 出現次數\n        map.put(0L, 1);\n        \n        long prexor = 0;\n        long res = 0;\n        for (int a : nums) {\n            prexor ^= a;  //每個bit 要不0次 要不就是1次\n            int v = map.getOrDefault(prexor, 0);  // 曾經出現的話表示 他們之間一定是偶數個bit\n            res += v;\n            //出現過表示 x x x x x [ x x x ] \n            //                 i       j\n            //               state    state\n            //                    ^^^^^^^^ 這段一定是偶數個bit\n            map.put(prexor, v + 1);\n        }\n        return res;\n\n\n\n        \n\n\n\n\n\n\n        \n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-the-number-of-beautiful-subarrays","has_notes":false,"flag_type":1}