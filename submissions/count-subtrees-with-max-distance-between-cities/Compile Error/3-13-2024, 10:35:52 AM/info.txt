{"id":1202092748,"question_id":1740,"lang":"java","lang_name":"Java","time":"3Â months","timestamp":1710297352,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1202092748/","is_pending":"Not Pending","title":"Count Subtrees With Max Distance Between Cities","memory":"N/A","code":"class Solution {\n    HashMap<Integer, Set<Integer>> adj;\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\n\n        adj = buildMap(edges);\n\n        vector<int>allow(n);\n        vector<int>rets(n,0);\n        vector<int>dist(n);\n\n        // List<Integer> allow = new ArrayList<>();\n        // List<Integer> rets  = new ArrayList<>();\n        // List<Integer> dist  = new ArrayList<>();\n        int[] allow = new int[n];\n        int[] rets = new int[n];\n        int[] dist = new int[n];\n        Arrays.fill(dist, -1);\n\n        for (int state=1; state<(1<<n); state++)\n        {\n            int start;\n            int count = 0;\n            for (int i=0; i<n; i++)\n            {\n                if (((state>>i)&1)==1)\n                {\n                    allow[i]=1;\n                    start = i;\n                    count++;\n                }                    \n                else\n                    allow[i]=0;\n            }\n            \n            int v1 = bfs(start, dist, allow);\n\n            int countVisited = 0;\n            for (int i=0; i<n; i++)\n                countVisited += (dist[i]!=-1);\n            if (countVisited!=count)\n                continue;\n            \n            for (int i=0; i<n; i++)\n                dist[i] = -1;\n            int v2 = bfs(v1, dist, allow);\n            int maxDist = *max_element(dist.begin(), dist.end());\n            \n            rets[maxDist]++;\n        }\n        \n        rets.erase(rets.begin());\n        return rets;        \n    }\n    \n    private int bfs(int start, int[] dis, int[] allow)\n    {\n        int n = dis.length;\n        \n        Queue<Integer> q = new LinkedList<>();\n        q.push(start);       \n        dis[start] = 0; \n        int maxDis = 0;\n        int maxId = start;\n        \n        while (!q.isEmpty()) \n        { \n            int cur = q.poll();\n            for (int next: adj.get(cur)) \n            {       \n                if (allow[next]==0) continue;\n                if (dis[next] == -1) \n                { \n                    q.offer(next);   \n                    dis[next] = dis[cur] + 1; \n                    if (dis[next] > maxDis)\n                    {\n                        maxDis = dis[next];\n                        maxId = next;\n                    }\n                } \n            } \n        }\n        return maxId; \n    }\n\n    private Map<Integer,Set<Integer>> buildMap(int[][] edges){\n\n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\n        \n        int len = edges.length;\n        for(int i=0; i<len; i++){\n            int u = edges[i][0]-1;\n            int v = edges[i][1]-1;\n            map.putIfAbsent(u, new HashSet<>());\n            map.putIfAbsent(v, new HashSet<>());\n            map.get(u).add(v);\n            map.get(v).add(u);\n        }\n\n    }\n}\n","compare_result":null,"title_slug":"count-subtrees-with-max-distance-between-cities","has_notes":false,"flag_type":1}