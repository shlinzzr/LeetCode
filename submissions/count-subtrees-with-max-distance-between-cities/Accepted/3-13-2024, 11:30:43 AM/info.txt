{"id":1202127424,"question_id":1740,"lang":"java","lang_name":"Java","time":"3Â months","timestamp":1710300643,"status":10,"status_display":"Accepted","runtime":"111 ms","url":"/submissions/detail/1202127424/","is_pending":"Not Pending","title":"Count Subtrees With Max Distance Between Cities","memory":"45.3 MB","code":"class Solution {\n    HashMap<Integer, Set<Integer>> adj;\n    public int[] countSubgraphsForEachDiameter(int n, int[][] edges) {\n\n        adj = buildMap(edges);\n\n        int[] allow = new int[n];\n        int[] rets = new int[n];\n        int[] dist = new int[n];\n\n        for (int state=1; state<(1<<n); state++) {\n\n            int start = 0;\n            int count = 0;\n            for (int i=0; i<n; i++) {\n\n                if (((state>>i)&1)==1) {\n                    allow[i]=1;\n                    start = i;\n                    count++;\n                }                    \n                else\n                    allow[i]=0;\n            }\n\n            Arrays.fill(dist, -1);\n            int v1 = bfs(start, dist, allow);\n\n            int countVisited = 0;\n            for (int i=0; i<n; i++)\n                countVisited += (dist[i]!=-1) ? 1 : 0;\n            if (countVisited!=count)\n                continue;\n             \n            Arrays.fill(dist, -1);\n            bfs(v1, dist, allow);\n\n            int maxDist = 0;\n            for(int i=0; i<n; i++){\n                maxDist = Math.max(maxDist, dist[i]);\n            }\n            \n            rets[maxDist]++;\n        }\n\n        int[] res = new int[n-1];\n        for(int i=1; i<n; i++){\n            res[i-1] = rets[i]; \n        }\n\n        return res;        \n    }\n    \n    private int bfs(int start, int[] dis, int[] allow)\n    {\n        int n = dis.length;\n        \n        Queue<Integer> q = new LinkedList<>();\n        q.offer(start);       \n        dis[start] = 0; \n        int maxDis = 0;\n        int maxId = start;\n        \n        while (!q.isEmpty()) \n        { \n            int cur = q.poll();\n            for (int next: adj.get(cur)) \n            {       \n                if (allow[next]==0) continue;\n                if (dis[next] == -1) { \n                    q.offer(next);   \n                    dis[next] = dis[cur] + 1; \n                    if (dis[next] > maxDis)\n                    {\n                        maxDis = dis[next];\n                        maxId = next;\n                    }\n                } \n            } \n        }\n        return maxId; \n    }\n\n    private HashMap<Integer,Set<Integer>> buildMap(int[][] edges){\n\n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\n        \n        int len = edges.length;\n        for(int i=0; i<len; i++){\n            int u = edges[i][0]-1;\n            int v = edges[i][1]-1;\n            map.putIfAbsent(u, new HashSet<>());\n            map.putIfAbsent(v, new HashSet<>());\n            map.get(u).add(v);\n            map.get(v).add(u);\n        }\n\n        return map;\n    }\n}\n","compare_result":"1111111111111111111111111111111","title_slug":"count-subtrees-with-max-distance-between-cities","has_notes":false,"flag_type":1}