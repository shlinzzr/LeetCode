{"id":1127919414,"question_id":2717,"lang":"java","lang_name":"Java","time":"5 months, 2 weeks","timestamp":1703486459,"status":10,"status_display":"Accepted","runtime":"123 ms","url":"/submissions/detail/1127919414/","is_pending":"Not Pending","title":"Collect Coins in a Tree","memory":"70.5 MB","code":"class Solution {\n    public int collectTheCoins(int[] coins, int[][] edges) {\n        Map<Integer, Set<Integer>> edgeList = initEdgeList(edges);\n        //used for trimming leaf nodes with no coins\n        Map<Integer, Boolean> hasCoins = initCoinMap(coins);\n        int remainingEdges = trimTree(edgeList, hasCoins);\n        //each edge that remains must be traversed exactly twice\n        int minSteps = remainingEdges * 2;\n        return minSteps;\n    }\n\n    private int trimTree(Map<Integer, Set<Integer>> edgeList, \n                                Map<Integer, Boolean> hasCoins) {\n        //these nodes will never be traversed so we remove them all\n        removeLeafNodesWithNoCoins(edgeList, hasCoins);\n        //you can reach up to two nodes that have coins so remove all leaf nodes twice\n        removeLeafNodes(edgeList, hasCoins, true);\n        removeLeafNodes(edgeList, hasCoins, true);\n        //a tree has nodeSize - 1 edges\n        //if tree is zero nodes therefore 0 edges return 0 instead of -1\n        return edgeList.size() > 1 ? edgeList.size() - 1 : 0;\n    }\n\n    private void removeLeafNodesWithNoCoins(Map<Integer, Set<Integer>> edgeList, \n                                            Map<Integer, Boolean> nodeToCoins) {\n        removeLeafNodes(edgeList, nodeToCoins, false);\n    }\n\n    private void removeLeafNodes(Map<Integer, Set<Integer>> edgeList, \n                            Map<Integer, Boolean> hasCoins, boolean removeAnyNode) {\n        LinkedList<Integer> q = new LinkedList<>();\n        for (Map.Entry<Integer, Set<Integer> > entry : edgeList.entrySet()) {\n            int node = entry.getKey();\n            int nodeDegree = entry.getValue().size();\n            //a leaf node has one edge\n            if (nodeDegree == 1 && (removeAnyNode || !hasCoins.get(node)))\n                q.addLast(node);\n        }\n        //removes leaf nodes with no coins\n        //or if in onion peeling step, remove leaf nodes with or without coins\n        while (q.size() > 0) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int leafNode = q.pollFirst();\n                Set<Integer> adjacentNodes = edgeList.get(leafNode);\n                //removes leaf node from adjacent nodes edgelist\n                //adds the adjacent node to queue\n                //if it becomes a new leaf node with desired properties\n                for (int adjacentNode : adjacentNodes) {\n                    Set<Integer> adjacentNodeAdjacentNodes = edgeList.get(adjacentNode);\n                    adjacentNodeAdjacentNodes.remove(leafNode);\n                    int adjacentNodeDegree = adjacentNodeAdjacentNodes.size();\n                    if (adjacentNodeDegree == 1 && \n                        (removeAnyNode || !hasCoins.get(adjacentNode)))\n                        q.addLast(adjacentNode);\n                }\n                //remove leafNode from map since it will never be stepped on\n                edgeList.remove(leafNode);\n            }\n            //only allowed one iteration if in step 2\n            if (removeAnyNode)\n                break;\n        }\n    }\n\n    private Map<Integer, Boolean> initCoinMap(int[] coins) {\n        Map<Integer, Boolean> hasCoins = new HashMap<>();\n        for (int i = 0; i < coins.length; i++)\n            hasCoins.put(i, coins[i] == 1);\n        return hasCoins;\n    }\n    \n    private Map<Integer, Set<Integer>> initEdgeList(int[][] edges) {\n        Map<Integer, Set<Integer>> edgeList = new HashMap<>();\n        for (int[] edge : edges) {\n            edgeList.computeIfAbsent(edge[0], key -> new HashSet<Integer>())\n                .add(edge[1]);\n            edgeList.computeIfAbsent(edge[1], key -> new HashSet<Integer>())\n                .add(edge[0]);\n        }\n        return edgeList;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"collect-coins-in-a-tree","has_notes":false,"flag_type":1}