{"id":1231359898,"question_id":3389,"lang":"java","lang_name":"Java","time":"2Â months","timestamp":1713024769,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1231359898/","is_pending":"Not Pending","title":"Minimum Time to Visit Disappearing Nodes","memory":"N/A","code":"class Solution {\n    public int[] minimumTime(int n, int[][] edges, int[] dis) {\n        int len = n;\n        int[] res = new int[n];\n        Arrays.fill(res, Integer.MAX_VALUE);\n        res[0]=0;\n        \n        \n//         Map<Integer, Map<Integer, Integer>> g = new HashMap<>();\n//         // Map<Integer, List<int[]>> g = new HashMap<>();\n        \n//         for(int[] e : edges){\n            \n//             int u = e[0];\n//             int v = e[1];\n//             int c = e[2];\n            \n//             g.putIfAbsent(u, new HashMap<>());\n//             g.putIfAbsent(v, new HashMap<>());\n            \n//             if(!g.get(u).containsKey(v) || g.get(u).get(v)>c){\n//                 g.get(u).put(v, c);\n//             }\n            \n            \n//             if(!g.get(v).containsKey(u) || g.get(v).get(u)>c){\n//                 g.get(v).put(u, c);\n//             }\n            \n            \n            \n// //             g.putIfAbsent(e[0], new ArrayList<>());\n// //             g.get(e[0]).add(new int[]{e[1], e[2]});\n            \n// //             g.putIfAbsent(e[1], new ArrayList<>());\n// //             g.get(e[1]).add(new int[]{e[0], e[2]});\n//         }\n        \n        \n              Map<Integer, List<int[]>> g = new HashMap<>();\n        for (int[] e : edges) {\n            int x = e[0];\n            int y = e[1];\n            int cost = e[2];\n            g.putIfAbsent(x, new ArrayList<>());\n            g.putIfAbsent(y, new ArrayList<>());\n            g.get(x).add(new int[]{y, cost});\n            g.get(y).add(new int[]{x, cost});\n        }\n        \n        \n//         for(int k : g.keySet()){\n//             Collections.sort(g.get(k), (a,b)-> a[1]-b[1]);\n//         }\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>( \n            (a,b) -> a[1]-b[1]\n        ); // node , time\n        \n        pq.offer(new int[]{0,0});\n        \n        while(!pq.isEmpty()){\n            int[] p = pq.poll();\n\n            int cur = p[0];\n            int time = p[1];\n            \n\n            // Map<Integer, Integer> adjs = g.getOrDefault(cur, new HashMap<>());\n            List<int[]> adjs = g.getOrDefault(cur, new ArrayList<>());\n\n            for(int[] adj: adjs){\n\n                int cost = adj[1];\n                int next = adj[0];\n\n\n                if( time+cost<res[next] && time+cost < dis[next] ){\n                    // System.out.println(\n                    // System.out.println(\"net= \" + next + \" t=\" + time+ \" cost=\" + cost + \" res=\"  + res[next]);\n                    res[next] = time + cost;\n                    pq.offer(new int[]{next, time+cost});\n                }\n\n            }\n                \n            \n           \n        }\n        \n        \n        for(int i=0; i<len ; i++){\n            if(res[i]==Integer.MAX_VALUE){\n                res[i] = -1;\n            }\n        }\n\n        return res;\n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110","title_slug":"minimum-time-to-visit-disappearing-nodes","has_notes":false,"flag_type":1}