{"id":960051870,"question_id":816,"lang":"java","lang_name":"Java","time":"1Â year","timestamp":1685427694,"status":10,"status_display":"Accepted","runtime":"18 ms","url":"/submissions/detail/960051870/","is_pending":"Not Pending","title":"Design HashSet","memory":"50.1 MB","code":"\nclass MyHashSet {\n  private Bucket[] bucketArray;\n  private int keyRange;\n\n  /** Initialize your data structure here. */\n  public MyHashSet() {\n    this.keyRange = 769;\n    this.bucketArray = new Bucket[this.keyRange];\n    for (int i = 0; i < this.keyRange; ++i)\n      this.bucketArray[i] = new Bucket();\n  }\n\n  protected int _hash(int key) {\n    return (key % this.keyRange);\n  }\n\n  public void add(int key) {\n    int bucketIndex = this._hash(key);\n    this.bucketArray[bucketIndex].insert(key);\n  }\n\n  public void remove(int key) {\n    int bucketIndex = this._hash(key);\n    this.bucketArray[bucketIndex].delete(key);\n  }\n\n  /** Returns true if this set contains the specified element */\n  public boolean contains(int key) {\n    int bucketIndex = this._hash(key);\n    return this.bucketArray[bucketIndex].exists(key);\n  }\n}\n\n\nclass Bucket {\n  private BSTree tree;\n\n  public Bucket() {\n    tree = new BSTree();\n  }\n\n  public void insert(Integer key) {\n    this.tree.root = this.tree.insertIntoBST(this.tree.root, key);\n  }\n\n  public void delete(Integer key) {\n    this.tree.root = this.tree.deleteNode(this.tree.root, key);\n  }\n\n  public boolean exists(Integer key) {\n    TreeNode node = this.tree.searchBST(this.tree.root, key);\n    return (node != null);\n  }\n}\n\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}\n\nclass BSTree {\n  TreeNode root = null;\n\n  public TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || val == root.val)\n      return root;\n\n    return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val);\n  }\n\n  public TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root == null)\n      return new TreeNode(val);\n\n    if (val > root.val)\n      // insert into the right subtree\n      root.right = insertIntoBST(root.right, val);\n    else if (val == root.val)\n      // skip the insertion\n      return root;\n    else\n      // insert into the left subtree\n      root.left = insertIntoBST(root.left, val);\n    return root;\n  }\n\n  /*\n   * One step right and then always left\n   */\n  public int successor(TreeNode root) {\n    root = root.right;\n    while (root.left != null)\n      root = root.left;\n    return root.val;\n  }\n\n  /*\n   * One step left and then always right\n   */\n  public int predecessor(TreeNode root) {\n    root = root.left;\n    while (root.right != null)\n      root = root.right;\n    return root.val;\n  }\n\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null)\n      return null;\n\n    // delete from the right subtree\n    if (key > root.val)\n      root.right = deleteNode(root.right, key);\n    // delete from the left subtree\n    else if (key < root.val)\n      root.left = deleteNode(root.left, key);\n    // delete the current node\n    else {\n      // the node is a leaf\n      if (root.left == null && root.right == null)\n        root = null;\n      // the node is not a leaf and has a right child\n      else if (root.right != null) {\n        root.val = successor(root);\n        root.right = deleteNode(root.right, root.val);\n      }\n      // the node is not a leaf, has no right child, and has a left child\n      else {\n        root.val = predecessor(root);\n        root.left = deleteNode(root.left, root.val);\n      }\n    }\n    return root;\n  }\n}\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */","compare_result":"111111111111111111111111111111111","title_slug":"design-hashset","has_notes":false,"flag_type":1}