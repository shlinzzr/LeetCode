{"id":756838835,"question_id":236,"lang":"java","lang_name":"Java","time":"1 year, 10 months","timestamp":1658803845,"status":10,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/756838835/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"49.3 MB","code":"// /**\n//  * Definition for a binary tree node.\n//  * public class TreeNode {\n//  *     int val;\n//  *     TreeNode left;\n//  *     TreeNode right;\n//  *     TreeNode(int x) { val = x; }\n//  * }\n//  */\n// // class Solution {\n// //     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n// //         Map<Integer, List<Integer>> map = new HashMap<>();\n        \n        \n        \n// //     }\n    \n    \n// //     private void helper(TreeNode root, Map<Integer, List<Integer>> map){\n        \n// //         if(root==null)\n// //             return;\n        \n// //         map.put(root.val, map.get(root))\n        \n        \n// //     }\n// // }\n// class Solution {\n\n//     private TreeNode ans;\n\n//     public Solution() {\n//         // Variable to store LCA node.\n//         this.ans = null;\n//     }\n\n//     private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {\n\n//         // If reached the end of a branch, return false.\n//         if (currentNode == null) {\n//             return false;\n//         }\n\n//         // Left Recursion. If left recursion returns true, set left = 1 else 0\n//         int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;\n\n//         // Right Recursion\n//         int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;\n\n//         // If the current node is one of p or q\n//         int mid = (currentNode == p || currentNode == q) ? 1 : 0;\n\n\n//         // If any two of the flags left, right or mid become True\n//         if (mid + left + right >= 2) {\n//             this.ans = currentNode;\n//         }\n\n//         // Return true if any one of the three bool values is True.\n//         return (mid + left + right > 0);\n//     }\n\n//     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n//         // Traverse the tree\n//         this.recurseTree(root, p, q);\n//         return this.ans;\n//     }\n// }\n\n\nclass Solution {\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        // Stack for tree traversal\n        Deque<TreeNode> stack = new ArrayDeque<>();\n\n        // HashMap for parent pointers\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n\n        parent.put(root, null);\n        stack.push(root);\n\n        // Iterate until we find both the nodes p and q\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\n\n            TreeNode node = stack.pop();\n\n            // While traversing the tree, keep saving the parent pointers.\n            if (node.left != null) {\n                parent.put(node.left, node);\n                stack.push(node.left);\n            }\n            if (node.right != null) {\n                parent.put(node.right, node);\n                stack.push(node.right);\n            }\n        }\n\n        // Ancestors set() for node p.\n        Set<TreeNode> ancestors = new HashSet<>();\n\n        // Process all ancestors for node p using parent pointers.\n        while (p != null) {\n            ancestors.add(p);\n            p = parent.get(p);\n        }\n\n        // The first ancestor of q which appears in\n        // p's ancestor set() is their lowest common ancestor.\n        while (!ancestors.contains(q))\n            q = parent.get(q);\n        return q;\n    }\n\n}","compare_result":"1111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":false,"flag_type":1}