{"id":1278044884,"question_id":1986,"lang":"java","lang_name":"Java","time":"1 week","timestamp":1717559720,"status":10,"status_display":"Accepted","runtime":"577 ms","url":"/submissions/detail/1278044884/","is_pending":"Not Pending","title":"Largest Color Value in a Directed Graph","memory":"80.2 MB","code":"class Solution {\r\n    List<List<Integer>> g;\r\n    int[] inDegree;\r\n\r\n    public int largestPathValue(String colors, int[][] edges)  {\r\n        int ans = 1;\r\n        int len = colors.length();\r\n\r\n        //buildMap, inDeg to find start point\r\n        inDegree = new int[len];\r\n        g = new ArrayList<>();\r\n        for(int i=0; i<len; i++){\r\n            g.add(new ArrayList<>());\r\n        }\r\n        for (int[] edge: edges){\r\n            int src = edge[0];\r\n            int dst = edge[1];\r\n            g.get(src).add(dst);\r\n            inDegree[dst]++;\r\n        }\r\n        \r\n        Set<Character> set = new HashSet<>();\r\n        for (char ch='a'; ch<='z'; ch++) // assumed largest color\r\n        {\r\n            if(!set.add(ch)) continue;\r\n            int t = helper(ch, colors, edges);\r\n            if(t==-1) return -1; // contains cycle\r\n            // how to find cycle => go throught all edge from which indeg==0,\r\n            // cnt the visited node should equal to colors.length()\r\n            // and use indeg to avoid infinte loop\r\n\r\n            ans = Math.max(ans, t);\r\n        }\r\n        return ans;        \r\n    }\r\n\r\n    private int helper(char ch, String colors, int[][] edges) {\r\n\r\n        int len = colors.length();\r\n        int[] count = new int[len];\r\n        int[] indeg = Arrays.copyOf(inDegree, len);\r\n        \r\n        int visited = 0;\r\n        //Queue<int[]> q = new LinkedList<>(); // => 錯的寫法\r\n         Queue<Integer> q = new LinkedList<>(); \r\n\r\n        // init q\r\n        for (int i=0; i<len; i++){\r\n            if (indeg[i]==0){\r\n                visited++;\r\n                // if (colors.charAt(i)==ch)\r\n                //     q.offer(new int[]{i, 1});\r\n                // else \r\n                //     q.offer(new int[]{i, 0});  // => 錯的寫法\r\n\r\n                if (colors.charAt(i)==ch){\r\n                    count[i]++;\r\n                }\r\n                q.offer(i);\r\n            }\r\n        }\r\n        \r\n        int ret = 0;\r\n        while (!q.isEmpty()){ \r\n\r\n        // bfs state 不能都存在 q 內, 可能之後的路 被帶了比較小的 state走到, \r\n        // let's largest assume color==2\r\n        // 2 - 2 -1- 1- \r\n        // \\       \\\r\n        //  0 0 0 0 0  \r\n        // ==> 此時上面累積比較多, 但是之後的路 下面的比較慢到 卻被下面走掉了\r\n        // 關鍵在於都是拉出來看統一的最大值, 不能放在Ｑ裡面做\r\n\r\n            int curr = q.poll();\r\n            \r\n            for (int next: g.get(curr)) {\r\n\r\n                count[next] = Math.max(count[next], count[curr]+(colors.charAt(next)==ch ? 1 : 0));                \r\n                // int state = p[1]+(colors.charAt(next)==ch ? 1 : 0); // => 錯的寫法\r\n                // ret = Math.max(ret, state);// => 錯的寫法\r\n                ret = Math.max(ret, count[next]);\r\n                indeg[next]--;\r\n                if (indeg[next]==0) {\r\n                    visited++;\r\n                    q.offer(next);\r\n                    // q.offer(new int[]{next, state});// => 錯的寫法\r\n                }\r\n            }            \r\n        }\r\n        \r\n        if (visited!=len) return -1;\r\n        return ret;\r\n    }\r\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"largest-color-value-in-a-directed-graph","has_notes":false,"flag_type":1}