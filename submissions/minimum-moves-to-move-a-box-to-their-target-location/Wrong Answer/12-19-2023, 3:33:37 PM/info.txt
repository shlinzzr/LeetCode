{"id":1123224998,"question_id":1389,"lang":"java","lang_name":"Java","time":"5 months, 3 weeks","timestamp":1702971217,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1123224998/","is_pending":"Not Pending","title":"Minimum Moves to Move a Box to Their Target Location","memory":"N/A","code":"class Solution {\n\n    int[][] dirs = new int[][]{{0,1}, {0, -1}, {1,0},{-1, 0}}; // right, left, down, up\n\n\n    public int minPushBox(char[][] grid) {\n        int h = grid.length;\n        int w = grid[0].length;\n\n        // 1. can b go t?\n        // 2a. s can't  go b => retrun false\n        // 2b  s can go b && (s can't go t) => return true;\n        // 2c  s can go b with 2 more way\n\n        // x x x x x x \n        // x t x x x x  \n        // x   b x x x  \n        // x x   x x x \n        // x x s x x x \n\n\n        int[] box = null;\n        int[] target = null;\n        int[] man = null;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(grid[i][j]=='B'){\n                    box = new int[]{i, j};\n                }\n                if(grid[i][j]=='T'){\n                    target = new int[]{i, j};\n                }\n                if(grid[i][j]=='S'){\n                    man = new int[]{i, j};\n                }\n\n                if(box!=null && target!=null && man!=null)\n                    break;\n            }\n        }\n\n\n        for(int[] d : dirs){  // {0,1}, {0, -1}, {1,0},{-1, 0}\n\n            int r = box[0] + d[0];\n            int c = box[1] + d[1];\n            int pr = box[0] - d[0];\n            int pc = box[1] - d[1];\n\n            if(r<0 || c<0 || r>=h || c>=h || grid[r][c]=='#')\n                continue;\n                \n            if( pr<0 || pc<0 || pr>=h || pc>=w || grid[pr][pc]=='#')\n                continue;\n\n            //check man can go {pr,pc}\n            int manToBoxPrev = canGo(grid, man, new int[]{pr,pc}, false);\n\n            int boxToTarget = canGo(grid, new int[]{r,c}, target, true);\n\n            System.out.println(manToBoxPrev + \" \" + boxToTarget);\n\n            if(manToBoxPrev>0 && boxToTarget>0)\n                return boxToTarget+1;\n        }\n\n        return -1;\n\n       /*\n       [[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]\n       ,[\"#\",\"T\",\"#\",\"#\",\"#\",\"#\"]\n       ,[\"#\",\".\",\".\",\"B\",\".\",\"#\"]\n       ,[\"#\",\".\",\"#\",\"#\",\".\",\"#\"]\n       ,[\"#\",\".\",\".\",\".\",\"S\",\"#\"]\n       ,[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\n\n       */\n\n\n    }\n\n    private int canGo(char[][]grid, int[] src, int[] tar, boolean checkPrev){\n\n        int h = grid.length;\n        int w = grid[0].length;\n\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(src);\n\n        int step = 1 ;\n        boolean[][] seen = new boolean[h][w];\n        //check box can go to target\n        while(!q.isEmpty()){\n           \n            int siz = q.size();\n\n            for(int i=0; i<siz; i++){\n                int[] p = q.poll();\n                for(int[] d: dirs){\n\n                    int r = p[0]+d[0];\n                    int c = p[1]+d[1];\n\n                    int pr = p[0]-d[0];\n                    int pc = p[1]-d[1];\n\n                    \n                    if(checkPrev && ( pr<0 || pc<0 || pr>=h || pc>=w || grid[pr][pc]=='#'))\n                        continue;\n\n                    if(r==tar[0] && c==tar[1])\n                        return step;\n\n                    if(r<0 || c<0 || r>=h || c>=h || grid[r][c]=='#' || seen[r][c] || grid[r][c]=='B')\n                        continue;\n\n                    seen[r][c] = true;\n                    q.offer(new int[]{r,c});\n                }\n            }\n            step++;\n        }\n\n        return -1;\n    }\n}","compare_result":"111100110101110111100000000000","title_slug":"minimum-moves-to-move-a-box-to-their-target-location","has_notes":false,"flag_type":1}