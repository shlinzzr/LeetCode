{"id":1149486125,"question_id":347,"lang":"java","lang_name":"Java","time":"4 months, 3 weeks","timestamp":1705558265,"status":10,"status_display":"Accepted","runtime":"13 ms","url":"/submissions/detail/1149486125/","is_pending":"Not Pending","title":"Top K Frequent Elements","memory":"45.1 MB","code":"        \n        // 1. hashmap + pq\n        // 2. quickselect !!\n\nclass Solution {\n    int[] unique;\n    Map<Integer, Integer> count;\n\n    \n    \n    public int[] topKFrequent(int[] nums, int k) {\n        // Build hash map: character and how often it appears\n        count = new HashMap();\n        for (int num: nums) {\n            count.put(num, count.getOrDefault(num, 0) + 1);\n        }\n        \n        // Array of unique elements\n        int n = count.size();\n        unique = new int[n]; \n        int i = 0;\n        for (int num: count.keySet()) {\n            unique[i] = num;\n            i++;\n        }\n        \n        // kth top frequent element is (n - k)th less frequent.\n        // Do a partial sort: from less frequent to the most frequent, till\n        // (n - k)th less frequent element takes its place (n - k) in a sorted array. \n        // All elements on the left are less frequent.\n        // All the elements on the right are more frequent. \n        quickselect(0, n - 1, n - k);\n        // Return top k frequent elements\n        return Arrays.copyOfRange(unique, n - k, n);\n    }\n\n    public void swap(int a, int b) {\n        int tmp = unique[a];\n        unique[a] = unique[b];\n        unique[b] = tmp;\n    }\n\n    public int partition(int left, int right, int pivot_index) {\n        int pivot_frequency = count.get(unique[pivot_index]);\n        // 1. Move pivot to end\n        swap(pivot_index, right);\n        int store_index = left;\n\n        // 2. Move all less frequent elements to the left\n        for (int i = left; i <= right; i++) {\n            if (count.get(unique[i]) < pivot_frequency) {\n                swap(store_index, i);\n                store_index++;\n            }\n        }\n\n        // 3. Move the pivot to its final place\n        swap(store_index, right);\n\n        return store_index;\n    }\n    \n    public void quickselect(int left, int right, int k_smallest) {\n        /*\n        Sort a list within left..right till kth less frequent element\n        takes its place. \n        */\n\n        // base case: the list contains only one element\n        if (left == right) return;\n        \n        //Select a random pivot_index\n        Random random_num = new Random();\n        int pivot_index = left + random_num.nextInt(right - left); \n\n        // Find the pivot position in a sorted list\n        pivot_index = partition(left, right, pivot_index);\n\n        // If the pivot is in its final sorted position\n        if (k_smallest == pivot_index) {\n            return;    \n        } else if (k_smallest < pivot_index) {\n            // go left\n            quickselect(left, pivot_index - 1, k_smallest);     \n        } else {\n            // go right \n            quickselect(pivot_index + 1, right, k_smallest);  \n        }\n        \n    }\n}","compare_result":"111111111111111111111","title_slug":"top-k-frequent-elements","has_notes":false,"flag_type":1}