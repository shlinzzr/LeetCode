{"id":923496930,"question_id":1300,"lang":"java","lang_name":"Java","time":"1 year, 2 months","timestamp":1679990681,"status":10,"status_display":"Accepted","runtime":"131 ms","url":"/submissions/detail/923496930/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"118.5 MB","code":"class Solution {\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        int[] disc = new int[n], low = new int[n];\n        // use adjacency list instead of matrix will save some memory, adjmatrix will cause MLE\n        List<Integer>[] graph = new ArrayList[n];\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.fill(disc, -1); // use disc to track if visited (disc[i] == -1)\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        // build graph\n        for (int i = 0; i < connections.size(); i++) {\n            int from = connections.get(i).get(0), to = connections.get(i).get(1);\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (disc[i] == -1) {\n                dfs(i, low, disc, graph, res, i);\n            }\n        }\n        return res;\n    }\n\n    int time = 0; // time when discover each vertex\n\n    private void dfs(int u, int[] low, int[] disc, List<Integer>[] graph, List<List<Integer>> res, int pre) {\n        disc[u] = low[u] = ++time; // discover u\n        for (int j = 0; j < graph[u].size(); j++) {\n            int v = graph[u].get(j);\n            if (v == pre) {\n                continue; // if parent vertex, ignore\n            }\n            if (disc[v] == -1) { // if not discovered\n                dfs(v, low, disc, graph, res, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // u - v is critical, there is no path for v to reach back to u or previous vertices of u\n                    res.add(Arrays.asList(u, v));\n                }\n            } else { // if v discovered and is not parent of u, update low[u], cannot use low[v] because u is not subtree of v\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}","compare_result":"11111111111111111","title_slug":"critical-connections-in-a-network","has_notes":false,"flag_type":1}