{"id":1262897084,"question_id":2914,"lang":"java","lang_name":"Java","time":"3 weeks, 2 days","timestamp":1716192311,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1262897084/","is_pending":"Not Pending","title":"Find the Safest Path in a Grid","memory":"N/A","code":"class Solution {\n    public int maximumSafenessFactor(List<List<Integer>> grid) {\n        \n        int h = grid.size();\n        int w = grid.get(0).size();\n\n        int[][] sf = new int[h][w];\n              for(int i=0; i<h; i++){ Arrays.fill(sf[i], h+w);}\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(grid.get(i).get(j)==1){\n                    sf[i][j] = 0;\n                    dfs(grid, sf, i, j);\n                }\n            }\n        }\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                System.out.print(sf[i][j]+ \",\");\n            }\n            System.out.println();\n        }\n        \n\n        int[][] dis = new int[h][w];\n        dis[0][0] = sf[0][0];\n\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0,0, sf[0][0]});\n\n        while(!q.isEmpty()){\n            \n            int[] p = q.poll();\n            int distance = p[2];\n\n            for(int[] d : dirs){\n                int r = d[0]+p[0];\n                int c = d[1]+p[1];\n                \n\n                if(r<0 || c<0 || r>=h || c>=w)\n                    continue;\n\n                int minD = Math.min(distance, sf[r][c]);\n\n                if(dis[r][c]>=minD)\n                    continue;\n                \n                q.offer(new int[]{r,c, minD});\n                dis[r][c] = minD;\n            }\n        }\n\n        return dis[h-1][w-1];\n\n\n\n\n    }\n    int[][] dirs = new int[][]{{1,0},{0, 1}, {-1,0}, {0,-1}};\n    private void dfs(List<List<Integer>> grid, int[][] sf, int i, int j){\n        int h = grid.size();\n        int w = grid.get(0).size();\n\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{i,j});\n        int step= 0;\n\n        while(!q.isEmpty()){\n            step++;\n            int size = q.size();\n            while(size-->0){\n                int[] p = q.poll();\n\n                for(int[] d : dirs){\n                    int r = p[0]+d[0];\n                    int c = p[1]+d[1];\n                    //  if(r<0 || c<0 || r>=h || c>=w ) continue;\n                        // System.out.println(p[0] + \" \"+p[1] + \"__>\" + r+ \" \"+c +\" step=\" + step+ \" sf[r][c=\"+ sf[r][c]);\n                    if(r<0 || c<0 || r>=h || c>=w || sf[r][c]<=step || grid.get(r).get(c)==1)\n                        continue;\n\n                        \n\n                    q.offer(new int[]{r,c});\n                    sf[r][c] = step;\n                }\n            }\n        }\n\n    }\n\n\n\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000","title_slug":"find-the-safest-path-in-a-grid","has_notes":false,"flag_type":1}