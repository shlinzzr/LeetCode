{"id":1117897884,"question_id":993,"lang":"java","lang_name":"Java","time":"6 months","timestamp":1702370110,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1117897884/","is_pending":"Not Pending","title":"Tallest Billboard","memory":"N/A","code":"class Solution {\n\n    /*\n\n    把一個n*n網格expand成(n+1)*(n+1)個node\n    初始化把n*n的四個邊parent都設為0\n    檢查端點有沒有相連\n\n    各端點都沒有連起來的時候 總count數==1\n\n\n\n\n    */\n\n    class UnionFind{\n        int[] parent;\n        int count;\n        public UnionFind(int n){\n            parent = new int[n];\n            for(int i=0; i<n; i++){\n                parent[i]=i;\n            }\n            count=1;\n        }\n\n        public int find(int x){\n            if(parent[x]!=x){\n                parent[x] = find(parent[x]);\n            }\n\n            return parent[x];\n        }\n\n        public void union(int a, int b){\n            a = find(a);\n            b = find(b);\n            if(a==b){ // a==b means the edge's are connected!!\n                count++;\n                return;\n            }\n\n            if(a<b){\n                parent[b]=a;\n            }else \n                parent[a]=b;\n        }\n    }\n\n\n    public int regionsBySlashes(String[] grid) {\n        int n = grid.length;\n\n        // 把一個n*n網格expand成(n+1)*(n+1)個node\n        UnionFind uf = new UnionFind((n+1)*(n+1));\n\n        for(int i=0; i<=n; i++){\n            for(int j=0;j<=n; j++){\n                int idx = i*(n+1)+j; // convert to 1d-array idx\n                if(i==0 || j==0 || i==n || j==n){ // initialize the edge's parent to 0\n                    uf.parent[idx]=0;\n                }\n            }\n        }\n\n        /*\n        when ch=='/':\n                      X = i*(n+1) + j+1\n        (i,  j),   (i, j+1)\n        (i+1,j), (i+1, j+1)\n           Y=(i+1)*(n+1) + j\n        \n\n        case : when ch=='\\\\'\n            X = i*(n+1)+j\n        (i,  j),   (i, j+1)\n        (i+1,j), (i+1, j+1)\n                      Y=(i+1)*(n+1) + j+1\n        */\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                char ch = grid[i].charAt(j);\n                \n                if (ch == '/') {\n\n                    int x = i * (n + 1) + j + 1;\n                    int y = (i + 1) * (n + 1) + j;\n                    uf.union(x, y);\n\n                } else if (ch == '\\\\') {\n                    int x = i * (n + 1) + j;\n                    int y = (i + 1) * (n + 1) + j + 1;\n                    uf.union(x, y);\n                }\n            }\n        }\n\n        return uf.count;\n\n        \n    }\n}","compare_result":null,"title_slug":"tallest-billboard","has_notes":false,"flag_type":1}