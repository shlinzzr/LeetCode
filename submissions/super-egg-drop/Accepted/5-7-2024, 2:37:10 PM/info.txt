{"id":1251523010,"question_id":923,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1715063830,"status":10,"status_display":"Accepted","runtime":"46 ms","url":"/submissions/detail/1251523010/","is_pending":"Not Pending","title":"Super Egg Drop","memory":"55.6 MB","code":"class Solution {\n     Integer dp[][]= new Integer [101][10001];\n    //here e is the number of eggs(k) and f is the number of floors(n)\n    public int superEggDrop(int e, int f) {\n\n        if(f==1 || f==0)\n            return f;\n        if(e==1)\n            return f;\n        \n        if(dp[e][f] != null) return dp[e][f];\n\n        int st=1, ed=f;\n        int min= Integer.MAX_VALUE;\n        \n        while(st<=ed)\n        {\n            int k = st+ (ed-st)/2; //here k is the middle floor\n                \n            // if egg breaks when dropped from the kth floor, \n            //then its sure that the egg will break \n            //if dropped from floors above k then we check for floors below k\n            // i.e. we go down\n                int down = superEggDrop(e-1, k-1); \n            \n            // if egg does not break when dropped from the kth floor, \n            //then its sure that the egg will not break \n            //if dropped from floors below k then we check for floors above k\n            // i.e. we go up\n                int up = superEggDrop(e, f-k);\n            \n            int temp=1+Math.max(down,up);\n            //adding one because we have used 1 attempt and max of up and down because\n            //we need worst case attempts from both\n            \n            if(down < up)\n                st= k+1;\n            else\n                ed= k-1;\n        \n             min = Math.min(temp, min); //min because we have to find the min no. of moves   \n            }\n        \n        return dp[e][f]=min;  \n    }\n}\n\n    // public int superEggDrop1(int k, int n) {\n    //     // find f:  0 <= f <= n\n\n    //     // k eggs, floors n\n    //     int[][] dp = new int[k+1][0][n]; // min # of move to check f with first i egg at floor j1 ~ j2\n\n\n    //     // if not broke\n    //     dp[i+1][j1][j2] = dp[i][(j1+j2)/2+1][j2] // mid+1 ~ ed\n\n    //     // if broke\n    //     dp[i+1][j1][j2] = dp[i][j1][(j1+j2)/2]; // st ~ mid\n    // }","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"super-egg-drop","has_notes":false,"flag_type":1}