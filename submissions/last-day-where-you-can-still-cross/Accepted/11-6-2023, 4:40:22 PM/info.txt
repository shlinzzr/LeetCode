{"id":1092656940,"question_id":2101,"lang":"java","lang_name":"Java","time":"7 months, 1 week","timestamp":1699260022,"status":10,"status_display":"Accepted","runtime":"21 ms","url":"/submissions/detail/1092656940/","is_pending":"Not Pending","title":"Last Day Where You Can Still Cross","memory":"54.4 MB","code":"class Solution {\n    public int latestDayToCross(int row, int col, int[][] cells) {\n        \n        UnionFind uf = new UnionFind(row, col);\n        \n        int[][] dirs = new int[][]{{0,1}, {1,0}, {-1,0} ,{0,-1}};\n        \n        //build grid\n        int[][] grid = new int[row][col];\n        for(int i=0; i<cells.length; i++){\n            int[] cell = cells[i];\n            int y = cell[0]-1;\n            int x = cell[1]-1;\n            grid[y][x] = 1;\n        }//所有水都淹過了\n        \n        for(int i=0; i<row; i++){\n            for(int j=0; j<col; j++){   //T(1e4)\n                \n                //union\n                if(grid[i][j]==0){\n                    for(int d[] : dirs){\n                    \n                        int r = d[0]+i;\n                        int c = d[1]+j;\n                        \n                        if(r<0 || c<0 || r>=row || c>=col || grid[r][c]==1)\n                            continue;\n                        \n                        boolean ures = uf.union(i*col+j, r*col+c);\n                        \n\n                        // 如果所有水都淹過了 仍然有陸地能cross 那答案就是最後一天\n                        if(ures) \n                            return cells.length;\n                    }\n                    \n                }\n            }\n        }\n        \n        //從最後一天開始往回看 把陸地加回去 (union)\n        for(int k=cells.length-1; k>=0; k--){\n            \n            int[] cell = cells[k];\n            \n            int y = cell[0]-1;\n            int x = cell[1]-1;\n            grid[y][x]=0;\n            \n            for(int[] d : dirs){\n                \n                int r = y+d[0];\n                int c = x+d[1];\n                \n                if(r<0 || c<0 || r>=row || c>=col || grid[r][c]==1)\n                    continue;\n                \n                boolean ures = uf.union(y*col+x, r*col+c);\n                            \n                if(ures)\n                     return k;\n            }\n        }\n        \n        return 0;\n    }\n    \n    \n    \n    \n    \n    class UnionFind{\n        \n        int[] parent;\n        int[] weight;\n        \n        int row; \n        int col;\n        \n        public UnionFind(int row, int col){\n            \n            this.row= row;\n            this.col = col;\n            \n            int n = row*col;\n            \n            this.parent = new int[n];\n            this.weight = new int[n];\n            \n            \n            for(int i=0; i<n; i++){\n                parent[i] = i;\n                weight[i] = 1;\n            }\n        }\n        \n        public int find(int x){\n            \n            if(parent[x]!=x){\n                parent[x] = find(parent[x]);\n            }\n            \n            return parent[x];\n        }\n        \n        public boolean union(int a, int b){\n            \n            a=find(a);\n            b=find(b);\n            \n            if(a==b)\n                return false;\n            \n            if( (a>=0 && a<col) || (a<row*col && a>= row*col-col)){\n                \n                parent[b] = a;\n                weight[a] += weight[b];\n                \n            }else{\n                parent[a] = b;\n                weight[b] += weight[a];\n            }\n            \n            \n            if( (a>=0 && a<col) && (b<row*col && b>= row*col-col) // a是first row 且b 是last row\n              ||(b>=0 && b<col) && (a<row*col && a>= row*col-col) ) // 或： b是first row, a是 last row\n                return true;\n            \n            return false;\n        }\n        \n    }\n    \n    \n    \n    \n    \n    private boolean isOk(int row, int col, int[][]cells, int mid){\n        \n        int[][] grid = new int[row][col];\n        for(int i=0; i<=mid; i++){\n            int[] cell = cells[i];\n            int y = cell[0]-1;\n            int x = cell[1]-1;\n            grid[y][x] = 1;\n        }\n        \n        \n        int[][] dirs = new int[][]{{0,1}, {1,0}, {-1,0} ,{0,-1}};\n        \n        Queue<int[]> q = new LinkedList<>();\n        \n        boolean[][] seen = new boolean[row][col];\n        \n        for(int j=0; j<col; j++){\n            if(grid[0][j]==0){\n                q.offer(new int[]{0, j});\n                seen[0][j]=true;\n            }\n        }\n        \n        while(!q.isEmpty()){\n            \n            for(int i=q.size(); i>0; i--){\n                \n                int[] p = q.poll();\n                \n                for(int[] d: dirs){\n                    \n                    int r = d[0] + p[0];\n                    int c = d[1] + p[1];\n                    \n                    if(r<0 || c<0 || r>=row || c>=col || seen[r][c] || grid[r][c]==1)\n                        continue;\n                    \n                    if(r==row-1)\n                        return true;\n                    \n                    seen[r][c]=true;\n                    q.offer(new int[]{r,c});\n                }\n            }\n        }\n        \n        return false;\n        \n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"last-day-where-you-can-still-cross","has_notes":false,"flag_type":1}