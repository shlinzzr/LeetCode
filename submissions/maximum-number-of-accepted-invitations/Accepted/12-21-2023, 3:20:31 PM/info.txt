{"id":1124884937,"question_id":1969,"lang":"java","lang_name":"Java","time":"5 months, 3 weeks","timestamp":1703143231,"status":10,"status_display":"Accepted","runtime":"70 ms","url":"/submissions/detail/1124884937/","is_pending":"Not Pending","title":"Maximum Number of Accepted Invitations","memory":"52.6 MB","code":"class Solution {\n    /*\n        Concept : Maximum Bipartite graph\n    */\n    public int maximumInvitations(int[][] grid) {\n        int m = grid.length; // boys\n        int n = grid[0].length; // girls\n\n        int[] girlFixed = new int[n];// girl[j] = boy\n        Arrays.fill(girlFixed, -1);\n\n        int invitations = 0;\n\n        // boy0 -> girlj\n        // try to find a girl for i but also make previous boys that have girls still have girls\n        for (int i = 0; i < m; i++) {\n            if (isBipartiteMatch(grid, i, new HashSet<>(), girlFixed)) {\n                invitations++;\n            }\n        }\n        return invitations;\n    }\n\n    private boolean isBipartiteMatch(int[][] grid, int boy, Set<Integer> seenGirl, int[] girlFixed) {\n        int m = grid.length; // boys\n        int n = grid[0].length; // girls\n\n        for (int j = 0; j < n; j++) {\n            if (grid[boy][j] == 1 && !seenGirl.contains(j)) {\n                seenGirl.add(j);\n                // found a non-match girl || another previous boy can find another non-match girl\n                if (girlFixed[j] == -1 || isBipartiteMatch(grid, girlFixed[j], seenGirl, girlFixed)) {\n                    girlFixed[j] = boy;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-number-of-accepted-invitations","has_notes":false,"flag_type":1}