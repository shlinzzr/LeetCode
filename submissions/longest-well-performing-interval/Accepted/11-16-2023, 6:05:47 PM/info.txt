{"id":1100001559,"question_id":1219,"lang":"java","lang_name":"Java","time":"6 months, 4 weeks","timestamp":1700129147,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1100001559/","is_pending":"Not Pending","title":"Longest Well-Performing Interval","memory":"44.7 MB","code":"class Solution {\n    public int longestWPI(int[] hours) {\n        int len = hours.length;\n\n\n/*\n[9,9,6,0,6,6,9] => [1,1,-1,-1,-1,-1,1]\npresum =>   [1,2,1,0,-1,-2,-1] \noffset => [0,1,2,1,0,-1,-2,-1]\n\n find maxLen Of [i, j] s.t. presum[j] - presum[i]>0  ==> presum[i]>presum[j]\n\n ref : leetcode 962\n\n*/\n\n        int[] presum = new int[len+1]; // offset\n        int sum = 0 ;\n        for(int i=0; i<len; i++){\n            sum += hours[i]>8 ? 1 : -1;\n            presum[i+1] = sum;\n        }\n\n\n        // find caddidate i, make stack desc\n        Stack<Integer> st = new Stack<>();\n        for(int i=0; i<len+1; i++){\n            if(st.isEmpty() || presum[st.peek()]>presum[i]){\n                st.push(i);\n            }\n        }\n\n        //find j to match from back, if match : calculate max\n        int max = 0;\n        for(int j=len; j>=0; j--){\n            while(!st.isEmpty() && presum[st.peek()]<presum[j]){\n                max = Math.max(max, j-st.pop());\n            }\n        }\n\n\n        return max;\n    }\n}\n\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-well-performing-interval","has_notes":false,"flag_type":1}