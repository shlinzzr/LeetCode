{"id":1263868836,"question_id":1219,"lang":"java","lang_name":"Java","time":"3 weeks, 1 day","timestamp":1716284667,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/1263868836/","is_pending":"Not Pending","title":"Longest Well-Performing Interval","memory":"45.2 MB","code":"class Solution {\n    public int longestWPI(int[] hours) {\n        int len = hours.length;\n\n\n/*\n[9,9,6,0,6,6,9] => [1,1,-1,-1,-1,-1,1]\npresum =>   [1,2,1,0,-1,-2,-1] \npresum => [0,1,2,1,0,-1,-2,-1]\n\n find maxLen Of [i, j] s.t. presum[j] - presum[i]>0  ==> presum[j]>presum[i]\n\n ref : leetcode 962\n\n*/\n\n        int[] presum = new int[len+1]; \n        int sum = 0 ;\n        for(int i=0; i<len; i++){\n            sum += hours[i]>8 ? 1 : -1;\n            presum[i+1] = sum;\n        }\n\n\n        // 對於i來說 若前一個presum[st.peek()] 比presum[i]還小 \n        // 就不用push stack了 因為更可能成立presum[j]>presum[i]而且位置還更遠\n        // else : push stack\n\n\n        Stack<Integer> st = new Stack<>();\n        // find caddidate i, make stack desc\n        // 後面雖然直比較小 也比較近 至少公式會成立\n        for(int i=0; i<len+1; i++){\n            if(st.isEmpty() || presum[st.peek()]>presum[i]){\n                st.push(i);\n            }\n        }\n\n        //對於j從後面來說 要找的是stack中最遠的i s.t. presum[j]> presum[st.peek()] \n        // 然後算 max = Math.max(max, j-st.pop)\n\n        //find j to match from back, if match : calculate max\n        int max = 0;\n        for(int j=len; j>=0; j--){\n            while(!st.isEmpty() && presum[st.peek()]<presum[j]){\n                max = Math.max(max, j-st.pop());\n            }\n        }\n\n\n        return max;\n    }\n}\n\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-well-performing-interval","has_notes":false,"flag_type":1}