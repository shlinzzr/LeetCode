{"id":922797376,"question_id":1728,"lang":"java","lang_name":"Java","time":"1 year, 2 months","timestamp":1679892166,"status":10,"status_display":"Accepted","runtime":"48 ms","url":"/submissions/detail/922797376/","is_pending":"Not Pending","title":"Fancy Sequence","memory":"94.5 MB","code":"class Fancy {\n    private static final int MOD = 1000000007;\n\n    // cache inverse values for 0-100\n    private static final int[] INV = IntStream.range(0, 101).map(Fancy::modInverse).toArray();\n\n    // Modular multiplicative inverse x => a * x % MOD == 1\n    private static int modInverse(int a) {\n        int m = MOD, y = 0, x = 1;\n        while (a > 1) {\n            int q = a / m;\n            int t = m;\n            m = a % m;\n            a = t;\n            t = y;\n\n            y = x - q * y;\n            x = t;\n        }\n        return x < 0 ? x + MOD : x;\n    }\n\n    private long mul = 1; // cumulative multiplication (%MOD)\n    private long add = 0; // cumulative addition (%MOD)\n\n    private long rmul = 1; // reverse cumulative multiplication (%MOD)\n    \n    // store base values, i.e. reverse cumulative transform are applied before addition \n    private final List<Integer> list = new ArrayList<>();\n    \n    public void append(int val) {\n        list.add((int) (((MOD - add + val) * rmul) % MOD));\n    }\n\n    public void addAll(int inc) {\n        add = (add + inc) % MOD;\n    }\n\n    public void multAll(int m) {\n        mul = (mul * m) % MOD;\n        rmul = (rmul * INV[m]) % MOD;\n        add = (add * m) % MOD;\n    }\n\n    public int getIndex(int idx) {\n        if (idx < list.size()) {\n            return (int) (((list.get(idx) * mul) + add) % MOD);\n        } else {\n            return -1;\n        }\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"fancy-sequence","has_notes":false,"flag_type":1}