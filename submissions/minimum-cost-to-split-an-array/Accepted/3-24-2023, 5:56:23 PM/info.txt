{"id":921223634,"question_id":2633,"lang":"java","lang_name":"Java","time":"1 year, 2 months","timestamp":1679651783,"status":10,"status_display":"Accepted","runtime":"426 ms","url":"/submissions/detail/921223634/","is_pending":"Not Pending","title":"Minimum Cost to Split an Array","memory":"42.5 MB","code":"class Solution {\n    public int minCost(int[] a, int k) {\n        int n = a.length;\n        int[] dp = new int[n + 1]; // dp[0] means optimal importance value for empty subarray, dp[1] means optimal importance value for array ending at[0, 1) i.e.[0, 0], dp[i] means optimal importance for array ending at i-1: [0, i) / [0, i-1]\n        for (int i = 1; i <= n; i++) { // calc result for dp[1] to dp[n]\n            dp[i] = Integer.MAX_VALUE;\n            HashMap<Integer, Integer> m = new HashMap<>(); // count map, a new one for each i\n            int score = k; // importance score always start with k for each subarray\n            for (int j = i - 1; j >= 0; j--) { // since we know the optimal value in dp[j] for j : [0, i-1], where to put j will we yield best score for dp[i]? (Note: j = 0 means two sub arrays: [0, 0) + [0, i) which means there's only one subarray which is the whole thing\n                int cnt = m.getOrDefault(a[j], 0);\n                m.put(a[j], ++cnt);\n                if (cnt == 2) score += 2; // only when we need a numnber for the second time, we start to add importance score, and it's going to be count as 2\n                else if (cnt > 2) score++; // for 3rd time and more, each time we count one more importance score\n                dp[i] = Math.min(dp[i], dp[j] + score);\n            }\n        }\n\n        return dp[n];\n    }\n}\n","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-to-split-an-array","has_notes":false,"flag_type":1}