{"id":901497990,"question_id":1768,"lang":"java","lang_name":"Java","time":"1 year, 3 months","timestamp":1676889921,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/901497990/","is_pending":"Not Pending","title":"Design an Expression Tree With Evaluate Function","memory":"39.8 MB","code":"/**\n * This is the interface for the expression tree Node.\n * You should not remove it, and you can define some classes to implement it.\n */\n\nabstract class Node {\n    public abstract int evaluate();\n    // define your fields here\n};\n// ref : https://leetcode.com/problems/design-an-expression-tree-with-evaluate-function/discuss/910018/C%2B%2BPython-The-Intended-Solution-During-The-Interview-Polymorphism\n\n/**\n * This is the TreeBuilder class.\n * You can treat it as the driver code that takes the postinfix input \n * and returns the expression tree represnting it as a Node.\n */\n\n/**\n * This is the interface for the expression tree Node.\n * You should not remove it, and you can define some classes to implement it.\n */\n\nclass NumNode extends Node {\n    int val;\n    public NumNode(int val) {\n        this.val = val;\n    }\n    \n    public int evaluate() {\n        return val;\n    }\n}\n\nabstract class OpNode extends Node {\n    Node left;\n    Node right;\n    \n    public OpNode(Node left, Node right) {\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass AddOpNode extends OpNode {\n    public AddOpNode(Node left, Node right) {\n        super(left, right);\n    }\n    public int evaluate() {\n        return this.left.evaluate() + this.right.evaluate();\n    }\n}\n\nclass SubOpNode extends OpNode {\n    public SubOpNode(Node left, Node right) {\n        super(left, right);\n    }\n    public int evaluate() {\n        return this.left.evaluate() - this.right.evaluate();\n    }\n}\n\nclass MultiplyOpNode extends OpNode {\n     public MultiplyOpNode(Node left, Node right) {\n        super(left, right);\n    }\n    \n    public int evaluate() {\n        return this.left.evaluate() * this.right.evaluate();\n    }\n}\n\nclass DivideOpNode extends OpNode {\n     public DivideOpNode(Node left, Node right) {\n        super(left, right);\n    }\n    public int evaluate() {\n        return this.left.evaluate() / this.right.evaluate();\n    }\n}\n\n\n/**\n * This is the TreeBuilder class.\n * You can treat it as the driver code that takes the postinfix input \n * and returns the expression tree represnting it as a Node.\n */\n\nclass TreeBuilder {\n    Node buildTree(String[] postfix) {\n        Stack<Node> st = new Stack<>();\n        for(String token : postfix) {\n            if (Character.isDigit(token.charAt(0))) {\n                st.push(new NumNode(Integer.parseInt(token)));\n            } else {\n                Node right = st.pop();\n                Node left = st.pop();\n                st.push(buildNode(token, left, right));\n            }\n        }\n        return st.peek();\n    }\n    \n    private Node buildNode(String op, Node left, Node right) {\n        switch(op) {\n            case \"+\":\n                return new AddOpNode(left, right);\n            case \"-\":\n                return new SubOpNode(left, right);\n            case \"*\":\n                return new MultiplyOpNode(left, right);\n            case \"/\":\n                return new DivideOpNode(left, right);\n            default:\n                return null;\n        }\n    }\n};\n\n\n/**\n * Your TreeBuilder object will be instantiated and called as such:\n * TreeBuilder obj = new TreeBuilder();\n * Node expTree = obj.buildTree(postfix);\n * int ans = expTree.evaluate();\n */\n\n\n/**\n * Your TreeBuilder object will be instantiated and called as such:\n * TreeBuilder obj = new TreeBuilder();\n * Node expTree = obj.buildTree(postfix);\n * int ans = expTree.evaluate();\n */","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"design-an-expression-tree-with-evaluate-function","has_notes":false,"flag_type":1}