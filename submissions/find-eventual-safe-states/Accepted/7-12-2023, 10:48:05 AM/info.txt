{"id":992302373,"question_id":820,"lang":"java","lang_name":"Java","time":"11 months, 1 week","timestamp":1689130085,"status":10,"status_display":"Accepted","runtime":"1222 ms","url":"/submissions/detail/992302373/","is_pending":"Not Pending","title":"Find Eventual Safe States","memory":"55.3 MB","code":"class Solution {\n    \n    int[] flag;\n    \n    \n    // ref 207 變化題\n    \n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        Set<Integer> res = new HashSet<>();\n        \n        int len = graph.length;\n        \n        flag = new int[len];\n        \n        // solution 0:\n        // UnionFind uf = new UnionFind(len); //第一個想法當然是uf, 但實際上有點沒法用\n        \n        // solution 2 : bfs find indegree=0\n        \n        Queue<Integer> q= new LinkedList<>();\n        \n        int[] outdegree = new int[len];\n        boolean[] seen = new boolean[len];\n        \n        \n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\n        for(int i=0; i<len; i++){\n            \n            outdegree[i] = graph[i].length;\n            \n            if(graph[i].length==0){\n                seen[i]=true;\n                q.offer(i);\n            }\n                \n            \n            for(int g : graph[i]){\n                map.putIfAbsent(g, new HashSet<>());\n                \n                map.get(g).add(i);\n            }\n            \n        }\n        \n        \n        \n        while(!q.isEmpty()){\n            \n            int p = q.poll();\n            res.add(p);\n            \n            \n            \n            \n            Set<Integer> prevSet = map.getOrDefault(p, new HashSet<>());\n            \n            \n                               \n                               \n            for(int prev : prevSet){\n                outdegree[prev]--;\n            }\n            \n            for(int i=0; i<len; i++){\n                if(seen[i]==false && outdegree[i]==0){\n                    res.add(i);\n                    q.offer(i);\n                    seen[i]=true;\n                }\n            }\n        }\n        \n        \n        List<Integer> list = new ArrayList<>(res);\n        Collections.sort(list);\n        \n        return list;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        // // solution 1 dfs find acyclic\n        // for(int i=0; i<len; i++){\n        //     if(dfs(i, graph))\n        //         res.add(i);\n        // }\n        // return res;\n    }\n    \n    // flag==1 permanent safe\n    // flag==2 current safe\n    \n    \n    private boolean dfs(int i, int[][] graph){\n        \n        if(flag[i]==1) return true;\n        if(flag[i]==2) return false;\n        \n        flag[i]=2;\n        for(int next : graph[i]){\n            if(dfs(next, graph)==false)\n                return false;\n        }\n        flag[i]=1;\n        return true;\n        \n        \n        \n    }\n    \n    \n    class UnionFind{\n        \n        int[] parent;\n        int[] weight;\n        \n        public UnionFind(int len){\n            \n            for(int i=0; i<len; i++){\n                parent[i] = i;\n                weight[i] = 1;\n            }\n        }\n        \n        public int find(int x){\n            \n            if(parent[x]!=x){\n                parent[x] = find(parent[x]);\n            }\n            \n            return parent[x];\n        }\n        \n        public void union(int a, int b){\n            \n            a = find(a);\n            b = find(b);\n            \n            if(a==b)\n                return;\n            \n            if(weight[a]>=weight[b]){\n                \n                parent[b] = a;\n                weight[a]+= weight[b];\n            }else{\n                parent[a] = b;\n                weight[b]+= weight[a];\n            }\n        }\n        \n        \n        \n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-eventual-safe-states","has_notes":false,"flag_type":1}