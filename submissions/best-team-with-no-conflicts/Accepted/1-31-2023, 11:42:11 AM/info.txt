{"id":888501710,"question_id":1748,"lang":"java","lang_name":"Java","time":"1 year, 4 months","timestamp":1675136531,"status":10,"status_display":"Accepted","runtime":"41 ms","url":"/submissions/detail/888501710/","is_pending":"Not Pending","title":"Best Team With No Conflicts","memory":"42 MB","code":"class Solution {\n    //https://leetcode.com/problems/best-team-with-no-conflicts/discuss/899631/Java-first-double-sort-then-DP\n    \n    \n    int res = 0;\n    public int bestTeamScore(int[] scores, int[] ages) {\n        int len = scores.length;\n        int[][] team = new int[len][2];\n        for (int i = 0; i < len; i++) {\n            team[i][0] = ages[i];\n            team[i][1] = scores[i]; // team is [age, score]\n        }\n\t\t// double sort first by age then by score, then we can traverse from young to old\n        Arrays.sort(team, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n        \n        int[] dp = new int[len];\n        // dp is the max sum for all sequences (not necessarily consecutive) ending in current idx\n        dp[0] = team[0][1];\n        for (int i = 1; i < len; i++) {\n            int max = team[i][1]; // At least it could start a new sequence by itself without extend\n\t\t\t// for each current idx, go visit all previous index to grow the sequences\n            for (int j = 0; j < i; j++) {\n                if (team[i][1] >= team[j][1]) {\n                    max = Math.max(max, dp[j] + team[i][1]);\n                }\n            }\n            dp[i] = max;\n        }\n      \n        int res = 0;\n        for (int num : dp) {\n            res = Math.max(res, num);\n        }\n        \n        return res;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"best-team-with-no-conflicts","has_notes":false,"flag_type":1}