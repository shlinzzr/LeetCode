{"id":1214023526,"question_id":1692,"lang":"java","lang_name":"Java","time":"2 months, 2 weeks","timestamp":1711423778,"status":10,"status_display":"Accepted","runtime":"125 ms","url":"/submissions/detail/1214023526/","is_pending":"Not Pending","title":"Number of Ways to Reorder Array to Get Same BST","memory":"55.4 MB","code":"class Solution {\n    private static final int M = (int)1e9+7;\n    public int numOfWays(int[] nums) {\n        List<Integer> list = new ArrayList<>();\n        for (int num : nums) {\n            list.add(num);\n        }\n        return countWays(list) - 1;\n    }\n    private int countWays(List<Integer> nums) {\n        if (nums.size() <= 2) { //兩個node, 第一個為root, 組bst只有一種組合方法\n            return 1;\n        }\n        \n        List<Integer> left = new ArrayList<>();\n        List<Integer> right = new ArrayList<>();\n        int root = nums.get(0);\n        \n        for (int i = 1; i < nums.size(); i++) {\n            if (nums.get(i) < root) {\n                left.add(nums.get(i));\n            } else {\n                right.add(nums.get(i));\n            }\n        }\n        \n        long leftCount = countWays(left);\n        long rightCount = countWays(right);\n        \n        return (int) ((comb(nums.size() - 1, left.size()) % M) * (leftCount % M) % M * (rightCount % M) % M);\n    }\n    \n    private long comb(int n, int k) { // C N取K\n        long[][] dp = new long[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n            for (int j = 1; j <= Math.min(i, k); j++) {\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % M;\n            }\n        }\n        return dp[n][k];\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-ways-to-reorder-array-to-get-same-bst","has_notes":false,"flag_type":1}