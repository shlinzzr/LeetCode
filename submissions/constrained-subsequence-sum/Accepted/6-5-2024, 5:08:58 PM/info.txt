{"id":1278291880,"question_id":1286,"lang":"java","lang_name":"Java","time":"1 week","timestamp":1717578538,"status":10,"status_display":"Accepted","runtime":"34 ms","url":"/submissions/detail/1278291880/","is_pending":"Not Pending","title":"Constrained Subsequence Sum","memory":"59.3 MB","code":"class Solution {\n    public int constrainedSubsetSum(int[] nums, int k) {\n\n        int len = nums.length;\n\n        Deque<int[]> dq = new ArrayDeque<>(); // idx, val // save recently k sum\n\n        int max = Integer.MIN_VALUE;\n        for(int i=0; i<len; i++){\n            int cur = nums[i];\n\n            while(!dq.isEmpty() && dq.peek()[0]<i-k){\n                dq.poll();\n            }\n\n            if(!dq.isEmpty()) cur+= dq.peek()[1]; //這邊都要留著, 之後可能會用到\n\n            max = Math.max(cur, max);\n\n            while(!dq.isEmpty() && dq.peekLast()[1] < cur){\n                dq.pollLast();\n            }\n\n            if(cur>0) dq.offer(new int[]{i, cur});\n\n        }\n\n        return max;\n         \n        //  ///[10,2,-10,5,20]\n        //  i==0:\n        // max = 10\n        // cur = 10\n        // dq = {0, 10}\n\n        // i==1:\n        // cur =12\n        // max = 12\n        // dq = {1, 12}\n\n        // i==2\n\n\n\n\n\n\n        // 題目 找max sum of subseq 其中每個相鄰element j-i<=k\n        // 想法1  : dp ? => O(NK) 會超時\n\n        // int len = nums.length;\n        // int[] dp = new int[len+1]; //  the maximum sum of a non-empty subsequence of that array  ending with nums[i-1];\n        // Arrays.fill(dp, Integer.MIN_VALUE/2);\n        // dp[1] = nums[0];\n        // for(int j=2; j<=len; j++){\n        //     dp[j] = Math.max(dp[j], nums[j-1]);\n        //     for(int i=j-1; j-i<=k && i>0; i--){\n        //         dp[j] = Math.max(dp[j], dp[i]+nums[j-1]);\n        //     }\n        // }\n        // int res = Integer.MIN_VALUE;\n        // for(int i=1; i<=len; i++){\n        //     res = Math.max(res, dp[i]);\n        // }\n        // return res;\n\n        // 也有treemap 的解法nlgn\n\n\n        // practice\n\n\n        // int len = nums.length;\n        // int max = Integer.MIN_VALUE;\n        // Deque<int[]> dq = new ArrayDeque<>(); // val, idx\n\n        // for(int i=0; i<len; i++){\n\n        //     //這邊很tricky\n        //     int sum = nums[i] + (dq.isEmpty() ? 0 : dq.peek()[0]); // sum 是從dq來的\n        //     max = Math.max(max, sum);\n\n        //     //小的拉掉\n        //     while(!dq.isEmpty() && dq.peekLast()[0]<sum){\n        //         dq.pollLast();\n        //     }\n\n        //     // 過期的 0 1 2 3, k==3\n        //     while(!dq.isEmpty() && dq.peek()[1]<=i-k){\n        //         dq.poll();\n        //     }\n\n            \n        //     if(sum>0){ //容易忘記: 有幫助的才加進dq\n        //         dq.offer(new int[]{sum, i});\n        //     }\n        // }\n\n        // return max;\n\n\n\n\n\n\n/*\n\n\n\n\n        // 想法2 : sliding window maximum (lc239), monostack O(N) :\n        // max subarray sum的話想到presum(lc862)\tsubseq的話 直接加prev\n        int len = nums.length;\n        Deque<int[]> dq = new ArrayDeque<>(); // idx, total\n        //[10,2,-10,5,20], k = 2\n\n        int res = Integer.MIN_VALUE;\n\n        for(int i=0; i<len; i++){\n            \n            // if dq not empty: previous total + nums\n            int total = nums[i] + (!dq.isEmpty() ?  dq.peek()[1] : 0); \n            res = Math.max(res, total);\n            \n            // remove all the smaller answer\n            while(!dq.isEmpty() && total > dq.peekLast()[1]){\n                dq.pollLast();\n            }\n\n            // remove the out of date idx\n            while(!dq.isEmpty() && i-dq.peek()[0]>=k){\n                dq.poll();\n            }\n\n            if(total>0)\n                dq.offer(new int[]{i, total});\n        }\n\n        return res;*/\n    }\n}","compare_result":"1111111111111111111111111111111111111111","title_slug":"constrained-subsequence-sum","has_notes":false,"flag_type":1}