{"id":1248165191,"question_id":354,"lang":"java","lang_name":"Java","time":"1 month, 1 week","timestamp":1714732541,"status":10,"status_display":"Accepted","runtime":"47 ms","url":"/submissions/detail/1248165191/","is_pending":"Not Pending","title":"Russian Doll Envelopes","memory":"102.5 MB","code":"class Solution {\n    public int maxEnvelopes(int[][] env) {\n\n        int len = env.length;\n\n        Arrays.sort(env, (a,b)-> a[0]!=b[0] ? a[0]-b[0] : b[1]-a[1]); \n        // which is already ensure sort asc by width\n        // then we find the lis 2d to 1d from height\n\n\n        //***********. this is important ***********/\n        // why we need sort height desc here is because :\n        // when we got the same width of envelopes, we want it height is max!!\n\n        List<Integer> list = new ArrayList<>();\n        \n        for(int i=0; i<len; i++){\n            \n            int cur = env[i][1];\n\n            if( list.isEmpty() || cur > list.get(list.size()-1) ){\n                list.add(cur);\n            }else{ // cur is too small\n                int x = binarySearch(list, cur);\n                list.set(x, cur);\n            }\n\n        }\n\n        return list.size();\n        \n    }\n    // to find the first element of list \n    // which is the \"first one who equal or greater\" than cur and replace it with smaller \"cur\"\n    private int binarySearch(List<Integer> list, int cur){\n\n        int st=0, ed= list.size()-1;\n\n        while(st<ed){ // 0 1\n            int mid = st+(ed-st)/2; // 0\n\n            int h = list.get(mid);\n\n            if(h==cur){\n                return mid;\n\n            }else if(h<cur){\n                st = mid+1; //1\n\n            }else{\n                ed = mid; //0\n            }\n        }\n\n        return st;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"russian-doll-envelopes","has_notes":false,"flag_type":1}