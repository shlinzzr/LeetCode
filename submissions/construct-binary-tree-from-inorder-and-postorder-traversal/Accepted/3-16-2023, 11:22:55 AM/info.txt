{"id":916021988,"question_id":106,"lang":"java","lang_name":"Java","time":"1 year, 2 months","timestamp":1678936975,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/916021988/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"41.8 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {        \n        return helper(inorder, 0, inorder.length-1, postorder, 0, postorder.length-1);\n    }\n\n    private TreeNode helper(int[] inorder, int ist, int ied, int[] postorder, int pst, int ped) {\n        \n        if(ist > ied || pst > ped) {\n            return null;\n        }\n        \n        TreeNode root = new TreeNode(postorder[ped]);\n        \n        // find the root index in inorder.\n        int idx = 0;\n        for(int i = 0; i < inorder.length; i++) {\n            if(inorder[i] == root.val) {\n                idx = i;\n                break;\n            } \n        }\n        root.left = helper(inorder, ist, idx-1, postorder, pst, pst + (idx-1-ist));\n        root.right = helper(inorder, idx+1, ied, postorder, pst + (idx-ist), ped-1);\n        \n        return root;\n        \n    }\n}\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false,"flag_type":1}