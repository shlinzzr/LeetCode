{"id":947090423,"question_id":2564,"lang":"java","lang_name":"Java","time":"1 year, 1 month","timestamp":1683615738,"status":10,"status_display":"Accepted","runtime":"47 ms","url":"/submissions/detail/947090423/","is_pending":"Not Pending","title":"Most Profitable Path in a Tree","memory":"98 MB","code":"class Solution {\n       public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\n        //Time: O(E); Space: O(N + E)\n        //build graph\n        List<Integer>[] graph = new ArrayList[amount.length];\n        for (int i = 0; i < amount.length; i++) graph[i] = new ArrayList<>();\n        for (int[] edge: edges) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        return helper_dfs(graph, 0, bob, amount, new boolean[amount.length], 1)[0];\n    }\n\n    //Time: O(N); Space: O(N)\n    private int[] helper_dfs(List<Integer>[] graph, int node, int bob, int[] amount, boolean[] seen, int height) {\n        int res = Integer.MIN_VALUE;\n        seen[node] = true;\n\n        int bobPathLen = node == bob ? 1 : 0;\n\n        for (int nextNode : graph[node]) {\n            if (seen[nextNode] == true) continue;\n            int[] tmp = helper_dfs(graph, nextNode, bob, amount, seen, height + 1);\n            if (tmp[1] > 0) bobPathLen = tmp[1] + 1;\n            res = Math.max(res, tmp[0]);\n        }\n\n        if (bobPathLen > 0 && bobPathLen <= height){\n            if (bobPathLen == height) amount[node] = amount[node] / 2;\n            else amount[node] = 0;\n        }\n\n        return new int[]{res == Integer.MIN_VALUE ? amount[node] : amount[node] + res, bobPathLen};\n    }\n}","compare_result":"1111111111111111111111111111111","title_slug":"most-profitable-path-in-a-tree","has_notes":false,"flag_type":1}