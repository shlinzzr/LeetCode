{"id":948897043,"question_id":2564,"lang":"java","lang_name":"Java","time":"1 year, 1 month","timestamp":1683878843,"status":10,"status_display":"Accepted","runtime":"67 ms","url":"/submissions/detail/948897043/","is_pending":"Not Pending","title":"Most Profitable Path in a Tree","memory":"91.7 MB","code":"class Solution {\n   List<Integer>[] tree;\n   int n;\n   int[] parents;\n   int[] dists;\n   int[] amount;\n   public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\n       n = amount.length;\n       this.amount = amount;\n       tree = new ArrayList[n];\n       for (int i = 0; i < n; i++) tree[i] = new ArrayList();\n       for (int[] e : edges) {\n           tree[e[0]].add(e[1]);\n           tree[e[1]].add(e[0]);\n       }\n\n       parents = new int[n];\n       dists = new int[n];\n\n       // Init parents and dists\n       dfs(0, 0, 0);\n\n       // Update amounts by calculating who is closer to a node in the path\n       int cur = bob;\n       int bd = 0;\n       while (cur != 0) {\n           if (dists[cur] > bd) {\n               amount[cur] = 0;\n           } else if (dists[cur] == bd) {\n               amount[cur] = amount[cur] / 2;\n           }\n           cur = parents[cur];\n           bd++;\n       }\n\n       // find the max net income for Alice\n       return dfs2(0);\n   }\n\n   private void dfs(int cur, int parent, int distance) {\n       dists[cur] = distance;\n       parents[cur] = parent;\n       for (int child : tree[cur]) {\n           if (child == parent) continue;\n           dfs(child, cur, distance + 1);\n       }\n   }\n\n   private int dfs2(int cur) {\n       int max = Integer.MIN_VALUE;\n       for (int child : tree[cur]) {\n           if (child == parents[cur]) continue;\n           max = Math.max(max, dfs2(child));\n       }\n       if (max == Integer.MIN_VALUE) return amount[cur];\n       return max + amount[cur];\n   }\n}","compare_result":"1111111111111111111111111111111","title_slug":"most-profitable-path-in-a-tree","has_notes":false,"flag_type":1}