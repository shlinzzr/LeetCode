{"id":947037287,"question_id":2564,"lang":"java","lang_name":"Java","time":"1 year, 1 month","timestamp":1683608739,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/947037287/","is_pending":"Not Pending","title":"Most Profitable Path in a Tree","memory":"N/A","code":"class Solution {\n    int max = 0;\n    \n    public int mostProfitablePath(int[][] edges, int bob, int[] amount) {\n        HashMap<Integer, HashSet<Integer>> adj = new HashMap<>();\n        \n        for(int[] e: edges){\n            adj.putIfAbsent(e[0], new HashSet<>());\n            adj.putIfAbsent(e[1], new HashSet<>());\n            adj.get(e[0]).add(e[1]);\n            adj.get(e[1]).add(e[0]);\n        }\n        \n        int len = amount.length;\n        boolean[] opened = new boolean[len];\n        \n        int[] steps = new int[len];\n        \n        boolean[] seen = new boolean[len];\n        \n        Queue<Integer> q = new LinkedList<>();\n        q.offer(bob);\n        seen[bob]=true;\n        \n       \n        \n        int step=0;\n        while(!q.isEmpty()){\n            int siz = q.size();\n            \n            for(int i=0; i<siz; i++){\n                \n                int p = q.poll();\n                \n                for(Integer next : adj.get(p)){\n                    if(next==null)\n                        continue;\n                    \n                    if(seen[next])\n                        continue;\n                    \n                    seen[next]=true;\n                    steps[next] = step;\n                    \n                    q.offer(next);\n                }\n                \n            }\n            \n            step++;\n        }\n        \n        seen = new boolean[len];\n        seen[0]=true;\n        dfs(adj, 0, 0, seen, false, amount, steps, 0);\n        return max;\n//         seen = new boolean[len];\n//         q = new LinkedList<>();\n//         q.offer(0);\n//         seen[0]=true;\n//         step=0;\n//         int curr=0;\n//          boolean compare = false;\n        \n//         int max = 0;\n        \n//         while(!q.isEmpty()){\n            \n//             int siz=q.size();\n//             for(int i=0; i<siz; i++){\n                \n//                 int p = q.poll();\n                \n//                 if(steps[p]>step)\n//                     curr+=amount[p];\n//                 else if(steps[p]==step){\n//                     curr += amount[p]/2;\n//                     compare = true;\n//                 }\n                    \n                \n                \n//                 System.out.println ( p + \" \" + curr);\n                \n//                  for(Integer next : adj.get(p)){\n//                     if(next==null)\n//                         continue;\n                    \n//                     if(seen[next])\n//                         continue;\n                     \n//                     seen[next]=true;\n//                     steps[next] = step;\n                    \n//                     q.offer(next);\n//                 }\n//             }\n//         }\n        \n//         return curr;\n        \n        \n        \n    }\n    \n    \n    \n    private void dfs( HashMap<Integer, HashSet<Integer>> adj , int curr, int val, boolean[] seen, boolean compare, int[] amount, int[] steps, int step){\n        \n        \n        HashSet<Integer> set = adj.get(curr);\n        val += amount[curr];\n        \n        if(compare)\n            max = Math.max(max, val);\n        \n        \n        if(step>=steps[curr])\n            compare=true;\n        \n        \n        for(int next :  set){\n            \n            if(seen[next]){\n                continue;\n            }\n            \n            seen[next]= true;\n            dfs(adj, next, val, seen, compare, amount, steps, step+1);\n        }\n        \n    }\n}","compare_result":"0000000000000000000010000000001","title_slug":"most-profitable-path-in-a-tree","has_notes":false,"flag_type":1}