{"id":1033699873,"question_id":3025,"lang":"java","lang_name":"Java","time":"9 months, 2 weeks","timestamp":1693192369,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1033699873/","is_pending":"Not Pending","title":"Minimum Operations to Form Subsequence With Target Sum","memory":"N/A","code":"class Solution {\n    public int minOperations(List<Integer> nums, int target) {\n        int sum =0;\n        for(int n : nums){\n            sum+=n;\n        }\n        if(sum<target)\n            return -1;\n        \n        // prepare need List\n        List<Integer> need= new ArrayList<>();\n        String s = Integer.toBinaryString(target);\n        char[] tarr = s.toCharArray(); //12 => 1100\n        for(int i=0; i<tarr.length;i++ ){\n            if(tarr[i]=='1'){\n                need.add(tarr.length-i-1);\n            }\n        }\n        \n        \n        // get have count\n        int[] count = new int[32];        \n        for(int n : nums){\n            int idx = Integer.toBinaryString(n).length()-1; //10\n            count[idx]++;\n        }\n        \n        if(need.size()==0)\n            return 0;\n        \n        Collections.sort(need);\n        \n        \n        // from wisdompeak\n        int res = 0;\n        for (int nd: need)\n        {\n            \n            //search from low\n            int lo = 0;\n            while (lo<nd)\n            {\n                count[lo+1] += count[lo] / 2;\n                count[lo] %= 2;\n                lo++;\n            }\n            if (lo==nd && count[nd]>0) \n            {\n                count[nd] -= 1; // 表示被用掉了\n                continue; //如果有找到從下面compose上來的 就不用往上找\n            }\n            \n            \n            //往上找 & divide by 2\n            \n            //找第一個最近的divide\n            while (lo<31 && count[lo]==0)\n                lo++;\n            if (lo==31) return -1;\n            count[lo] -= 1; //最高位-1\n            for (int k=lo-1; k>=nd; k--) // 其他的一路過來都+1\n                count[k]+=1;\n            \n            res += lo-nd;\n        }\n\n        \n        \n        return res;\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010100010100100011010000101110110111111101110111010111001101100000100100001000010010111010000011011100111000001100101011101100110010011011000001000101111001101111110","title_slug":"minimum-operations-to-form-subsequence-with-target-sum","has_notes":false,"flag_type":1}