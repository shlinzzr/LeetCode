{"id":1110123723,"question_id":1684,"lang":"java","lang_name":"Java","time":"6 months, 2 weeks","timestamp":1701423744,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1110123723/","is_pending":"Not Pending","title":"Find Latest Group of Size M","memory":"N/A","code":"class Solution {\n    public int findLatestStep(int[] arr, int m) {\n        int len = arr.length;\n\n        if(m==len) return len;\n\n        int[] day = new int[len]; // day : 1-index, \n\n        for(int i=0; i<len; i++){\n            day[arr[i]-1]=i+1;\n        }\n\n        Deque<Integer> dq = new ArrayDeque<>();\n\n        int res = Integer.MIN_VALUE;\n\n        // sliding (window size m)'s maximum  : [i, j] = t\n        // for i到j區間 [i, j] 都必須<t, 且(day[i-1]>t && day[j+1]>t ) , \n        // 意思即是在 t = min(day[i-1], day[j+1])-1 前 就是latest step \n        for(int j=0; j<len; j++){\n            while(!dq.isEmpty() && day[dq.peekLast()]<day[j]){\n                dq.pollLast();\n            }\n            while(!dq.isEmpty() && j-dq.peek()+1>m){\n                dq.poll();\n            }\n            dq.offer(j);\n\n            // m=5 : x x x j-m [x x x x j] j+1\n\n            int t = day[dq.peek()];\n            if(j-m>=0 && day[j-m]>t && j+1<len && day[j+1]>t){\n                res = Math.max(res,  Math.min(day[j-m], day[j+1]));\n            }\n        }\n\n        return res == Integer.MIN_VALUE ? -1 : res;\n        \n    }\n}","compare_result":"111101000001100011101111001110110000000110111101110111001111111111111011101111111011111011111111001111111111110000","title_slug":"find-latest-group-of-size-m","has_notes":false,"flag_type":1}