{"id":1278394676,"question_id":1694,"lang":"java","lang_name":"Java","time":"1 week","timestamp":1717586738,"status":10,"status_display":"Accepted","runtime":"37 ms","url":"/submissions/detail/1278394676/","is_pending":"Not Pending","title":"Make Sum Divisible by P","memory":"60.6 MB","code":"class Solution {\n    public int minSubarray(int[] nums, int p) {\n\n        // pre-condition\n\n        long sum = 0 ;\n        for(int n : nums)\n            sum += n;\n        long offset = sum%p;\n        if(offset==0) return 0;\n\n        int len = nums.length;\n        Map<Long, Integer> map = new HashMap<>(); // sum, idx\n        map.put(0L, -1);\n        int res = len;\n\n        long[] presum = new long[len];\n        for(int i=0; i<len; i++){\n            presum[i] = i==0 ? nums[i] : presum[i-1] + nums[i];\n\n            long mod =  (presum[i]-offset+p)%p;  // +p to avoid negative mod\n\n            // (presum[i]-offset)%p == presum[j] 如果有在map內找到 \n            // 表示 presum[i]-presum[j] 這段中間的subarray 包含了 offset\n            //去掉中間這段 表示前後都可以被p 整除 \n            // => x x x x [x x x x ]  x x x x \n            //          j        i \n            // presum[i] = presum[j] + offset => find( presum[i]-offset )\n\n            if(map.containsKey(mod)){\n                res = Math.min(res, i-map.get(mod));\n            }\n\n            map.put(presum[i]%p, i);\n        }\n        return res == len ? -1 : res;\n\n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"make-sum-divisible-by-p","has_notes":false,"flag_type":1}