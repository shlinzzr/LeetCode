{"id":1248109929,"question_id":892,"lang":"java","lang_name":"Java","time":"1 month, 1 week","timestamp":1714726996,"status":10,"status_display":"Accepted","runtime":"41 ms","url":"/submissions/detail/1248109929/","is_pending":"Not Pending","title":"Shortest Subarray with Sum at Least K","memory":"62.8 MB","code":"class Solution {\n    public int shortestSubarray(int[] nums, int k) {    \n\n        int len = nums.length;\n        long[] presum = new long[len];\n        for(int i=0; i<len; i++){\n            presum[i] = i==0L ? (long)nums[0] : presum[i-1] + (long)nums[i];\n        }\n\n\n        // 找 shortest\n        // nums  2 -1 2\n        // presum 2 1 3\n        //        i. cur  : --> peek(i) presum[cur]-presum[i] >= k  有的話就pop() 求min\n        // poll() ---->找近的i \n        // 除此之外 要把前面比自己大的cur都幹掉 \n        // 因為自己相對於前面 presum更小的話 更容易滿足k 也更近\n        // 如果沒做 容易把自己卡在前面 沒滿足K 掛在半路上\n        Deque<Integer> dq = new ArrayDeque<Integer>();\n        int min = len+1;\n        for(int i=0; i<len; i++){\n            long cur = presum[i];\n\n            //base case\n            if(cur>=k){ \n                min = Math.min(min, i+1);\n            }\n\n            //這才是關鍵 把前面候選人幹掉\n            while(!dq.isEmpty() && cur<=presum[dq.peekLast()]){\n                dq.pollLast();\n            }\n\n            // 從左向右邊 往 shortest i 逼近\n            while(!dq.isEmpty() && cur-presum[dq.peek()]>=k){\n                min = Math.min(min, i-dq.poll());\n            }\n\n\n            dq.offer(i);\n\n\n        }\n\n        return min==len+1 ? -1 : min;\n        \n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-subarray-with-sum-at-least-k","has_notes":false,"flag_type":1}