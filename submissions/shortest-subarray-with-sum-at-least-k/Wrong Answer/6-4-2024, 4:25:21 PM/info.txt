{"id":1277224894,"question_id":892,"lang":"java","lang_name":"Java","time":"1 week, 1 day","timestamp":1717489521,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1277224894/","is_pending":"Not Pending","title":"Shortest Subarray with Sum at Least K","memory":"N/A","code":"class Solution {\n    public int shortestSubarray(int[] nums, int k) {    \n\n        // subarray sum 直接想到presum \n        int len = nums.length;\n        int[] presum = new int[len];\n        for(int i=0; i<len; i++){\n            presum[i] = i==0 ? nums[0] : nums[i] + presum[i-1];\n        }\n        \n        // find sliding window minimum\n\n        Deque<Integer> dq = new ArrayDeque<>(); //  idx\n\n        int min = len+1;\n\n        for(int i=0; i<len; i++){\n\n            int cur = presum[i];\n            // base case \n            if(cur>=k) min = Math.min(min, i+1);\n\n            // the cur is smaller than previous insert element\n            // means the cur is more opptunity fullfill k and will be more shorter\n            while(!dq.isEmpty() && cur<=presum[dq.peekLast()]){\n                dq.pollLast();\n            }\n\n            while(!dq.isEmpty() && cur-presum[dq.peek()]>=k ){\n                min = Math.min(min, i-dq.poll()+1);\n            }\n\n            dq.offer(i);\n\n        }        \n\n        return min==len+1? -1 : min;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        // int len = nums.length;\n        // long[] presum = new long[len];\n        // for(int i=0; i<len; i++){\n        //     presum[i] = i==0L ? (long)nums[0] : presum[i-1] + (long)nums[i];\n        // }\n\n\n        // // 找 shortest\n        // // nums  2 -1 2\n        // // presum 2 1 3\n        // //        i. cur  : --> peek(i) presum[cur]-presum[i] >= k  有的話就pop() 求min\n        // // poll() ---->找近的i \n        // // 除此之外 要把前面比自己大的cur都幹掉 \n        // // 因為自己相對於前面 presum更小的話 更容易滿足k 也更近\n        // // 如果沒做 容易把自己卡在前面 沒滿足K 掛在半路上\n        // Deque<Integer> dq = new ArrayDeque<Integer>();\n        // int min = len+1;\n        // for(int i=0; i<len; i++){\n        //     long cur = presum[i];\n\n        //     //base case : presum[i]直接>＝k min: nums[0:i], 長度i+1\n        //     if(cur>=k){ \n        //         min = Math.min(min, i+1);\n        //     }\n\n        //     //這才是關鍵 把前面候選人幹掉 對於上一個加入的 peekLast來說\n        //     // 如果 cur<= presum[peeklast()] 表示我sum更小, presum[i]來減更容易達成k 更靠近i陣列長度也會更小\n        //     while(!dq.isEmpty() && cur<=presum[dq.peekLast()]){\n        //         dq.pollLast();\n        //     }\n\n        //     // 從左向右邊 往 shortest i 逼近\n        //     // 已經達成k, 過小&過遠的 head poll掉\n        //     while(!dq.isEmpty() && cur-presum[dq.peek()]>=k){\n        //         min = Math.min(min, i-dq.poll());\n        //     }\n\n\n        //     dq.offer(i);\n        // }\n\n        // return min==len+1 ? -1 : min;\n        \n    }\n}","compare_result":"11111001010001010101001000000000010000001000000000001000000000000000000000000000000000000000100010","title_slug":"shortest-subarray-with-sum-at-least-k","has_notes":false,"flag_type":1}