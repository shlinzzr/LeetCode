{"id":1009901817,"question_id":2135,"lang":"java","lang_name":"Java","time":"10 months, 2 weeks","timestamp":1690946366,"status":10,"status_display":"Accepted","runtime":"182 ms","url":"/submissions/detail/1009901817/","is_pending":"Not Pending","title":"Maximum Number of Ways to Partition an Array","memory":"62 MB","code":"class Solution {\n    public int waysToPartition(int[] nums, int k) {\n        // x x x x [x x x x]\n        //      i-1 i     k\n        // p[k]-p[i-1]=p[i-1]\n        // ==> p[k] = 2p[i-1]\n//         int res = 0;\n//         int len = nums.length;\n//         HashMap<Integer, Integer> map = new HashMap<>();\n//         int presum = 0;\n        \n//         for(int i=0; i<len; i++){\n//             presum += nums[i];\n            \n//             if(presum%2==0){\n//                 res += map.getOrDefault(presum/2, 0);\n//             }\n            \n            \n//             map.put(presum,  map.getOrDefault(presum, 0)+1);\n//         }\n        \n        int len = nums.length;\n        \n      \n        \n        long[] pre = new long[len];\n        pre[0] = nums[0];\n        for (int i=1; i<len; i++)\n            pre[i] = pre[i-1]+nums[i];        \n        \n        long[] suf = new long[len];\n        suf[len-1] = nums[len-1];\n        for (int i=len-2; i>=0; i--)\n            suf[i] = suf[i+1]+nums[i];        \n        \n        long sum = 0;\n        for(int n : nums){\n            sum+=n;\n        }\n        \n        \n        Map<Long, Integer> count = new HashMap<>();\n        \n        // 分析 更換的k可能落在前半段或後半段\n        // x x x x x x [ x x k x x ] //假設更換的i在後半段\n        long[] rets = new long[len]; //代表更換第i個num時的答案\n        for (int i=0; i<len; i++){\n            long new_sum = sum + k-nums[i];\n            if (new_sum % 2 == 0)\n                rets[i] += count.getOrDefault(new_sum/2, 0); \n            \n            //填入org presum\n            count.put(pre[i], count.getOrDefault(pre[i],0)+1);\n        }\n        count.clear();\n        \n        // [x x x k x x] x x x x x  //倒過來 假設更換的i在前半段\n        for (int i=len-1; i>=0; i--)\n        {\n            long new_sum = sum + k-nums[i];\n            if (new_sum % 2 == 0)\n                rets[i] += count.getOrDefault(new_sum/2, 0);\n            \n            //填入org sufsum\n            count.put(suf[i], count.getOrDefault(suf[i],0)+1);\n        }         \n        \n        long ret = 0;\n        for (int i=0; i<len-1; i++)\n        {\n            if (pre[i]==sum-pre[i])\n                ret++;\n        }\n        \n        for (int i=0; i<len; i++)\n            ret = Math.max(ret, rets[i]);\n        \n        return (int)ret;        \n        \n        \n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-number-of-ways-to-partition-an-array","has_notes":false,"flag_type":1}