{"id":1124964404,"question_id":2201,"lang":"java","lang_name":"Java","time":"5 months, 3 weeks","timestamp":1703150913,"status":10,"status_display":"Accepted","runtime":"209 ms","url":"/submissions/detail/1124964404/","is_pending":"Not Pending","title":"Valid Arrangement of Pairs","memory":"133.6 MB","code":"class Solution {\n    // map to track all outcoming edges for given vertex\n    HashMap<Integer, Stack<Integer>> map = new HashMap<>();\n\n    public int[][] validArrangement(int[][] pairs) {\n        \n        // map to calculate outdegree - indegree\n        HashMap<Integer, Integer> indeg = new HashMap<>();\n\n        for (int[] p : pairs) {\n            map.putIfAbsent(p[0], new Stack<>());\n            map.get(p[0]).push(p[1]);\n\n            indeg.put(p[1], indeg.getOrDefault(p[1], 0)+1);\n            indeg.put(p[0], indeg.getOrDefault(p[0], 0)-1);\n        }\n\n        /*\n            Based on task description our graph at least has Eulerian path\n            or possible even circle.\n            If it has circle, we can start from any node (let's take the first vertex)\n            If the graph has Eulerian path only, in this case there will be exactly\n            one vertex with degree -1, this will be our start node.\n        */\n        int start = pairs[0][0];\n        for (int[] p : pairs) {\n            if (indeg.get(p[0]) == -1) {\n                start = p[0];\n                break;\n            }\n        }\n\n        // build the path in reverse order\n        List<Integer> path = new ArrayList<>();        \n        dfs(start, path);\n        // reverse it\n        Collections.reverse(path);\n\n        int[][] res = new int[pairs.length][2];\n\n        // build the result\n        for (int i = 0; i < path.size()-1; i++) {\n            res[i][0] = path.get(i);\n            res[i][1] = path.get(i+1);\n        }\n\n        return res;\n    }\n\n    public void dfs(int cur, List<Integer> path) {\n        while (map.containsKey(cur) && map.get(cur).size() > 0) {\n            dfs(map.get(cur).pop(), path);\n        }\n        path.add(cur);\n    }\n}","compare_result":"111111111111111111111111111111111111111","title_slug":"valid-arrangement-of-pairs","has_notes":false,"flag_type":1}