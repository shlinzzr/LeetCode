{"id":1015179267,"question_id":480,"lang":"java","lang_name":"Java","time":"10 months, 1 week","timestamp":1691455971,"status":10,"status_display":"Accepted","runtime":"82 ms","url":"/submissions/detail/1015179267/","is_pending":"Not Pending","title":"Sliding Window Median","memory":"55.7 MB","code":"class Solution {\n   public double[] medianSlidingWindow(int[] nums, int k) {\n        Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;\n        TreeSet<Integer> left = new TreeSet<>(comparator.reversed());\n        TreeSet<Integer> right = new TreeSet<>(comparator);\n\n        Supplier<Double> median = (k % 2 == 0) ?\n            () -> ((double) nums[left.first()] + nums[right.first()]) / 2 :\n            () -> (double) nums[right.first()];\n\n        // balance lefts size and rights size (if not equal then right will be larger by one)\n        Runnable balance = () -> { while (left.size() > right.size()) right.add(left.pollFirst()); };\n\n        double[] result = new double[nums.length - k + 1];\n\n        for (int i = 0; i < k; i++) left.add(i);\n        balance.run(); result[0] = median.get();\n\n        for (int i = k, r = 1; i < nums.length; i++, r++) {\n            // remove tail of window from either left or right\n            if(!left.remove(i - k)) right.remove(i - k);\n\n            // add next num, this will always increase left size\n            right.add(i); left.add(right.pollFirst());\n\n            // rebalance left and right, then get median from them\n            balance.run(); result[r] = median.get();\n        }\n\n        return result;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111","title_slug":"sliding-window-median","has_notes":false,"flag_type":1}