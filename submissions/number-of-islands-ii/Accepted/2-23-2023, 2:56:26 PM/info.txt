{"id":903366802,"question_id":305,"lang":"java","lang_name":"Java","time":"1 year, 3 months","timestamp":1677135386,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/903366802/","is_pending":"Not Pending","title":"Number of Islands II","memory":"66.5 MB","code":"class Solution {\n    \n    private class UnionFind {\n        int[] parent;\n        int[] rank;\n        \n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            Arrays.fill(parent, -1);\n        }\n        \n        public boolean union(int p, int q) {\n            int pRoot = find(p);\n            int qRoot = find(q);\n            if (pRoot == qRoot) {\n                return false;\n            }\n            if (rank[pRoot] < rank[qRoot]) {\n                parent[pRoot] = qRoot;\n            } else if (rank[pRoot] > rank[qRoot]) {\n                parent[qRoot] = pRoot;\n            } else {\n                parent[qRoot] = pRoot;\n                rank[pRoot]++;\n            }\n            return true;\n        }\n        \n        public int find(int index) {\n            while (index != parent[index]) {\n                parent[index] = parent[parent[index]];\n                index = parent[index];\n            }\n            return index;\n        }\n    }\n    \n    public List<Integer> numIslands2(int m, int n, int[][] positions) {\n        List<Integer> result = new ArrayList<>();\n        if (m == 0 || n == 0 || positions == null || positions.length == 0 || positions[0].length == 0) {\n            return result;\n        }\n        int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        UnionFind uf = new UnionFind(m * n);\n        int count = 0;\n        for (int[] position : positions) {\n            int x = position[0];\n            int y = position[1];\n            int p = x * n + y;\n            if (uf.parent[p] != -1) {   // duplicate position\n                result.add(count);\n                continue;\n            }\n            uf.parent[p] = p;\n            count++;\n            for (int[] dir : DIRS) {\n                int r = x + dir[0];\n                int c = y + dir[1];\n                if (isValid(uf, m, n, r, c)) {\n                    int q = r * n + c;\n                    if (uf.union(p, q)) {\n                        count--;\n                    }\n                }\n            }\n            result.add(count);\n        }\n        return result;\n    }\n    \n    private boolean isValid(UnionFind uf, int m, int n, int r, int c) {\n        if (r < 0 || c < 0 || r >= m || c >= n || uf.parent[r * n + c] == -1) {\n            return false;\n        }\n        return true;\n    }\n}\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-islands-ii","has_notes":false,"flag_type":1}