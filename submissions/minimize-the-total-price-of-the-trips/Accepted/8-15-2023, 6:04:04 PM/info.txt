{"id":1021935681,"question_id":2739,"lang":"java","lang_name":"Java","time":"10Â months","timestamp":1692093844,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1021935681/","is_pending":"Not Pending","title":"Minimize the Total Price of the Trips","memory":"43.8 MB","code":"class Solution {\n\n    List<Integer>[] next = new ArrayList[55];\n    int[] plan0 = new int[55];\n    int[] plan1 = new int[55];\n    int[] count = new int[55];\n    int[] val = new int[55];\n    \n    \n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\n        \n        // Arrays.fill(next, new ArrayList<>());\n        \n        for (int[] e: edges)\n        {\n            int a = e[0], b = e[1];\n            \n            if(next[a]==null)\n                next[a] = new ArrayList<>();\n            \n            if(next[b]==null)\n                next[b] = new ArrayList<>();\n            \n            next[a].add(b);\n            next[b].add(a);\n        }\n        \n        Arrays.fill(plan0, -1);\n        Arrays.fill(plan1, -1);\n        \n        \n        for (int[] trip: trips)\n        {\n            dfs(trip[0], -1, trip[1]);\n        }\n        \n        for (int i=0; i<n; i++)\n        {\n            val[i] = price[i]*count[i];\n        }\n        \n        return DFS(0, -1, 1);\n    }\n    \n    private boolean dfs(int cur, int parent, int target)\n    {        \n        if (cur==target) \n        {\n            count[cur]++;\n            return true;\n        }            \n        if(next[cur]!=null)\n        for (int x: next[cur])\n        {\n            if (x==parent) continue;\n            if (dfs(x, cur, target))\n            {\n                count[cur]++;\n                return true;                \n            }                \n        }\n        return false;\n    }\n    \n    private int DFS(int node, int parent, int flag)  // flag = 1 : can choose;  flag = 0 : cannot choose \n    {                \n        if (flag==0 && plan0[node]!=-1) return plan0[node];\n        if (flag==1 && plan1[node]!=-1) return plan1[node];        \n                \n        if (flag==0)\n        {\n            int ret = val[node];\n            if(next[node]!=null){\n                for (int x: next[node])\n                {\n                    if (x==parent) continue;\n                    ret += DFS(x, node, 1);\n                }        \n            }\n            plan0[node] = ret;\n            return ret;\n        }\n        else\n        {\n            int ret = Integer.MAX_VALUE;\n            int option1 = val[node]/2;\n            \n            if(next[node]!=null){\n                for (int x: next[node])\n                {\n                    if (x==parent) continue;\n                    option1 += DFS(x, node, 0);\n                }\n            }\n                \n            \n            int option2 = val[node];\n            if(next[node]!=null)\n            for (int x: next[node])\n            {\n                if (x==parent) continue;\n                option2 += DFS(x, node, 1);\n            }\n                        \n            ret = Math.min(option1, option2);\n            plan1[node] = ret;\n            return ret;\n        }                \n        \n    }\n}\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimize-the-total-price-of-the-trips","has_notes":false,"flag_type":1}