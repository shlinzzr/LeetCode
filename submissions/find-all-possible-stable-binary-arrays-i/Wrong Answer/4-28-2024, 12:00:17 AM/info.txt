{"id":1243404983,"question_id":3406,"lang":"java","lang_name":"Java","time":"1 month, 2 weeks","timestamp":1714233617,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1243404983/","is_pending":"Not Pending","title":"Find All Possible Stable Binary Arrays I","memory":"N/A","code":"class Solution {\n    public int numberOfStableArrays(int zero, int one, int limit) {\n        //Each subarray of arr with a size greater than limit must contain both 0 and 1.\n        // => Each subarray of arr  which at most only contains the \"limit\" continuous 0 or 1\n        // the length of array must be \"zero\" + \"one\"\n        \n        \n        // limit==1 1 0 1 0 1 => +-1\n        // limit==2, 1 1 0 0 1 1 => +-2\n        \n\n            \n            \n            // one / (zero+1) > limit\n        \n        // 11011\n            \n           // zero = 1, one = 4, limit =2\n        if( (Double.valueOf(one) /  Double.valueOf(zero+1)) > limit \n           ||  (Double.valueOf(zero)/ Double.valueOf(one+1))>limit) return 0;\n        \n        // the total cnt are \"the con zero 1~limit\" + the con one 1~limit\n        //全部 - 不符合的\n        \n        // 2 ^(z+o) - (limit+1 0)\n        \n        int len = zero + one ;\n        \n//         len=8\n//         subLen = 6\n        \n//         x x x x x | x x x \n//         0 0 0 0 0   1\n//         1 1 1 1 1   0\n            \n//         0 x x x x   1\n            \n            \n        \n        long illegal = 0;\n            \n        \n        \n        // zero = 3, one = 3, limit =2\n        \n        // limit =3 zero =4 one =1 , len 5\n        // 00001\n        \n        for(int subLen=limit+1; subLen<=zero; subLen++){\n            \n            int z = zero - subLen;\n\n            \n            illegal += (len-subLen+1) * combination(one, z);\n            \n            for(int conOne=limit+1; conOne<=one; conOne++){\n                \n                int o = one-conOne;\n                \n                 illegal -= (len-subLen-conOne+1) * combination(o, z);\n            }\n            \n           \n        }\n        \n//         11011\n//         111 \n        \n        for(int subLen=limit+1; subLen<=one; subLen++){\n            \n            int o = one-subLen;\n            illegal +=( len-subLen+1)*  combination(o, zero); // 1 1==2. 5-3+1\n            \n            for(int conZero=limit+1; conZero<=zero; conZero++){\n            \n                int z = zero - conZero;\n                illegal -= (len-subLen-conZero+1) * combination(o, z);\n            }\n        }\n           System.out.println( \" illegal 1=\" + illegal);\n        \n        long total =  combination(zero, one);\n            \n            \n        \n        int M = (int) 1e9+7;\n        \n        total %=M;\n        \n        System.out.println(total + \" \" + illegal);\n       \n        \n        int res =(int) (total - illegal);\n        return res < 0 ? 0 :res ;\n            \n            \n        \n    }\n    \n    public  long factorial(int n) {\n        if (n == 0 || n == 1) {\n            return 1;\n        }\n        long result = 1;\n        for (int i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n\n    // 計算排列組合的方法\n    public long combination(int n, int m) {\n        // 計算 n!⋅m! / (n+m)!\n        return factorial(n + m) / (factorial(n) * factorial(m));\n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111110111111011111110111111110111111110111111011111101111111101111111101111111001111100111110011111100111111100111111100111111100111100011111001111100111111100111111000111111100111111000111100011110001111000111110001111110001111110001111110001111000011100001111000111100011111100011111000011111000011100000111000011100001111000011111000011110000011100000111000011100001111100001111000001110000011000001110000011110000011100000110000011110000011000000110000001100000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"find-all-possible-stable-binary-arrays-i","has_notes":false,"flag_type":1}