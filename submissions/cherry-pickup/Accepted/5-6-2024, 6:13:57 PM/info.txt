{"id":1250753779,"question_id":741,"lang":"java","lang_name":"Java","time":"1 month, 1 week","timestamp":1714990437,"status":10,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/1250753779/","is_pending":"Not Pending","title":"Cherry Pickup","memory":"45 MB","code":"class Solution {\n    public int cherryPickup(int[][] grid) {\n        int N = grid.length;\n        int[][][] dp = new int[N+1][N+1][N+1];\n        \n        for (int i=0; i<=N; i++)\n            for (int j=0; j<=N; j++)\n                for (int x=0; x<=N; x++)\n                    dp[i][j][x] = Integer.MIN_VALUE;\n        \n       \n\n        for (int i=1; i<=N; i++)\n            for (int j=1; j<=N; j++)\n                for (int x=1; x<=N; x++){\n\n                    int y = i+j-x; //y是固定的 可以少一個維度\n                    if (y<1||y>N) // y:[1,N]\n                        continue;\n\n                    if (grid[i-1][j-1]==-1 || grid[x-1][y-1]==-1) // -1不能走 : continue\n                        continue;\n\n                    if (i==1 && j==1 && x==1){\n                        dp[i][j][x] = grid[0][0];\n                        continue;\n                    }\n\n                    dp[i][j][x] = Math.max(dp[i][j][x], dp[i-1][j][x-1]);\n                    dp[i][j][x] = Math.max(dp[i][j][x], dp[i][j-1][x-1]);\n                    dp[i][j][x] = Math.max(dp[i][j][x], dp[i-1][j][x]);\n                    dp[i][j][x] = Math.max(dp[i][j][x], dp[i][j-1][x]);\n                    \n                    if (i==x && j==y) //當i,j == x,y 時 只加一次grid[i][j]\n                        dp[i][j][x] += grid[i-1][j-1];\n                    else\n                        dp[i][j][x] += grid[i-1][j-1] + grid[x-1][y-1];\n                    \n                }\n        \n        return Math.max(0, dp[N][N][N]);\n        \n    }\n}","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"cherry-pickup","has_notes":false,"flag_type":1}