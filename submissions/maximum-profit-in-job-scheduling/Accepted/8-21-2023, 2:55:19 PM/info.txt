{"id":1027380234,"question_id":1352,"lang":"java","lang_name":"Java","time":"9 months, 3 weeks","timestamp":1692600919,"status":10,"status_display":"Accepted","runtime":"22 ms","url":"/submissions/detail/1027380234/","is_pending":"Not Pending","title":"Maximum Profit in Job Scheduling","memory":"51.2 MB","code":"class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        \n        // 1. treeMap 最簡單 但tricky 解法很專一 無通用性\n        // 2. dp 最套路的方式 最佳解\n        // 3. 用binary search 找 previous 邊界條件不好想\n        \n        \n        \n        \n        // treemap 126 ms, 8.96%\n        int len = startTime.length;\n        int[][] jobs = new int[len][3];\n        for(int i=0; i<len; i++){\n            jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        \n        Arrays.sort(jobs, (a,b) -> (a[1]-b[1]));\n        \n//         TreeMap<Integer, Integer> map = new TreeMap<>();\n//         map.put(0,0);\n//         for(int i=0; i<len; i++){\n//             int cur = map.floorEntry(jobs[i][0]).getValue() + jobs[i][2];\n//             if(cur>map.lastEntry().getValue()){\n//                 map.put(jobs[i][1], cur);\n//             }\n//         }\n//         return map.lastEntry().getValue();\n        \n        /*\n         *   dp array+bisearch 63ms, 49.86%\n         */\n        \n        int n =len;\n        int[] dp = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i + 1] = Math.max(dp[i], dp[i + 1]);\n            int lo = 0, hi = i-1;\n            while(lo < hi) {\n                int m = hi- (hi - lo)/ 2;\n                if (jobs[m][1] <= jobs[i][0]) { //找一個m的endTime  s.t 這個endTime<=目前的 stTime\n                    lo = m;\n                } else {\n                    hi = m-1;\n                }\n            }\n            \n            // [ x x x ]  [ x x x i ] \n            //      m.ed<=i.st\n            \n            //再次確認 (jobs[lo][1] <= jobs[i][0])\n            // if(jobs[lo][1] <= jobs[i][0])\n            //     val = jobs[i][2]+dp[m-1];\n            // else\n            //     val = jobs[i][2];\n            \n            dp[i + 1] = Math.max(dp[i + 1], ((jobs[lo][1] <= jobs[i][0]) ? dp[lo + 1] : 0) + jobs[i][2]);\n        }\n        return dp[n];\n        \n        \n    }\n}","compare_result":"111111111111111111111111111111","title_slug":"maximum-profit-in-job-scheduling","has_notes":false,"flag_type":1}