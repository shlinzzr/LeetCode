{"id":1027419620,"question_id":1352,"lang":"java","lang_name":"Java","time":"9 months, 3 weeks","timestamp":1692604529,"status":10,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/1027419620/","is_pending":"Not Pending","title":"Maximum Profit in Job Scheduling","memory":"51.5 MB","code":"class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        \n        // 2023/8/21 Summary :\n        // 1. treeMap 最簡單 但tricky 解法很專一 無通用性\n        // 2. dp 最套路的方式 最佳解\n        // 3. 用binary search 找 previous 邊界條件不好想\n\n        // solution dp:\n        int len = startTime.length;\n\n        int[][] jobs = new int[len+1][3];  // pre process offset\n        for(int i=0; i<len; i++){\n            jobs[i+1] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        Arrays.sort(jobs, (a,b) ->  a[1]-b[1]);\n        \n        int dp[] = new int[len+1]; // 做到第i筆job時的 max profit\n        dp[0] = jobs[1][2]; // 初始值 就是第1筆job的profit\n        \n        for(int i=1; i<=len; i++){\n            dp[i] = Math.max(jobs[i][2], dp[i-1]); \n            // dp[i] = Math.max(dp[i], dp[i-1]);  //每次先跟之前比\n            \n            for(int j=i-1; j>0; j--){ //由後往前找第一個\n                if(jobs[j][1]<=jobs[i][0]){ //檢查之前的job, 如果之前的edTime <= 現在的 stTime\n                    \n                    //注意這裡dp不用offset, job要offset\n                    dp[i] = Math.max(dp[i], dp[j]/*當時max profit*/ + jobs[i][2]/*這次job的profit*/);\n                    break;\n                }\n            }\n        }\n        return dp[len];\n  \n        \n        \n/*\n        // follow 2830 套路 => Memory Exceeded , dp宣告太1e9太大\n        int len = startTime.length;\n        \n        int max= 0 ;\n        for(int i=0; i<len; i++){\n            max = Math.max(max, endTime[i]);\n        }\n        \n        int[] dp = new int[max+1];\n        \n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for(int i=0; i<len; i++){\n            map.putIfAbsent(endTime[i], new ArrayList<>());\n            map.get(endTime[i]).add(new int[]{startTime[i], endTime[i], profit[i]});\n        }\n        \n        for(int i=1; i<=max; i++){\n            \n            dp[i] = dp[i-1];\n            for(int[] arr : map.getOrDefault(i, new ArrayList<>())){\n                dp[i] = Math.max(dp[i], dp[arr[0]] + arr[2]);\n            }\n        }\n        \n        return dp[max];\n        */\n        \n        \n        \n        \n        \n//         // treemap 126 ms, 8.96%\n//         int len = startTime.length;\n//         int[][] jobs = new int[len][3];\n//         for(int i=0; i<len; i++){\n//             jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n//         }\n//         Arrays.sort(jobs, (a,b) -> (a[1]-b[1]));\n        \n// //         TreeMap<Integer, Integer> map = new TreeMap<>();\n// //         map.put(0,0);\n// //         for(int i=0; i<len; i++){\n// //             int cur = map.floorEntry(jobs[i][0]).getValue() + jobs[i][2];\n// //             if(cur>map.lastEntry().getValue()){\n// //                 map.put(jobs[i][1], cur);\n// //             }\n// //         }\n// //         return map.lastEntry().getValue();\n        \n//         /*\n//          *   dp array+bisearch 63ms, 49.86%\n//          */\n        \n//         int n =len;\n//         int[] dp = new int[n + 1];\n//         for (int i = 0; i < n; i++) {\n//             dp[i + 1] = Math.max(dp[i], dp[i + 1]);\n//             int lo = 0, hi = i-1;\n//             while(lo < hi) {\n//                 int m = hi- (hi - lo)/ 2;\n//                 if (jobs[m][1] <= jobs[i][0]) { //找一個m的endTime  s.t 這個endTime<=目前的 stTime\n//                     lo = m;\n//                 } else {\n//                     hi = m-1;\n//                 }\n//             }\n            \n//             // [ x x x ]  [ x x x i ] \n//             //      m.ed<=i.st\n            \n//             //需再次確認 (jobs[lo][1] <= jobs[i][0])\n//             // if(jobs[lo][1] <= jobs[i][0])\n//             //     val = jobs[i][2]+dp[m-1];\n//             // else\n//             //     val = jobs[i][2];\n//             // dp[i+1] = Math.max(dp[i+1], val);\n            \n//             dp[i + 1] = Math.max(dp[i + 1], ((jobs[lo][1] <= jobs[i][0]) ? dp[lo + 1] : 0) + jobs[i][2]);\n//         }\n//         return dp[n];\n        \n        \n    }\n}","compare_result":"111111111111111111111111111111","title_slug":"maximum-profit-in-job-scheduling","has_notes":false,"flag_type":1}