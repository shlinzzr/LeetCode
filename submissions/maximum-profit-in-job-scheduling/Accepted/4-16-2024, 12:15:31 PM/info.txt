{"id":1233619905,"question_id":1352,"lang":"java","lang_name":"Java","time":"1 month, 3 weeks","timestamp":1713240931,"status":10,"status_display":"Accepted","runtime":"32 ms","url":"/submissions/detail/1233619905/","is_pending":"Not Pending","title":"Maximum Profit in Job Scheduling","memory":"55.9 MB","code":"class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        \n        // 2023/8/21 Summary :\n        // 1. treeMap 最簡單 但tricky 解法很專一 無通用性 8%\n        // 2. dp 最套路的方式 5%\n        // 3. 用dp +. binary search 最佳解 49.86%\n\n        // solution 2 : dp:\n        // int len = startTime.length;\n\n        // int[][] jobs = new int[len+1][3];  // pre process offset\n        // for(int i=0; i<len; i++){\n        //     jobs[i+1] = new int[]{startTime[i], endTime[i], profit[i]};\n        // }\n        // Arrays.sort(jobs, (a,b) ->  a[1]-b[1]);\n        \n        // int dp[] = new int[len+1]; // 做到第i筆job時的 max profit\n        // dp[0] = jobs[1][2]; // 初始值 就是第1筆job的profit\n        \n        // for(int i=1; i<=len; i++){\n        //     dp[i] = Math.max( dp[i-1], jobs[i][2]);   //不做job, profit=i-1\n            \n        //     for(int j=i-1; j>0; j--){ //由後往前找\"第一個\" //這裡可以改成二分搜值!!!\n        //         if(jobs[j][1]<=jobs[i][0]){ //找\"第一個\" : 檢查之前的job, 如果之前的edTime <= 現在的 stTime 就找到了, break\n                    \n        //             dp[i] = Math.max(dp[i], dp[j]/*當時max profit*/ + jobs[i][2]/*這次job的profit*/);\n        //             break;\n        //         }\n        //     }\n        // }\n        // return dp[len];\n  \n        \n        \n/*\n        // 用時間來滾 從第一秒滾到 last endTime\n        // follow 2830 套路 => Memory Exceeded , dp宣告太1e9太大\n    \n        int len = startTime.length;\n        \n        int max= 0 ;\n        for(int i=0; i<len; i++){\n            max = Math.max(max, endTime[i]);\n        }\n        \n        int[] dp = new int[max+1];\n        \n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for(int i=0; i<len; i++){\n            map.putIfAbsent(endTime[i], new ArrayList<>());\n            map.get(endTime[i]).add(new int[]{startTime[i], endTime[i], profit[i]});\n        }\n        \n\n         // 用時間來滾\n        for(int i=1; i<=max; i++){\n            \n            dp[i] = dp[i-1];\n            for(int[] arr : map.getOrDefault(i, new ArrayList<>())){\n                dp[i] = Math.max(dp[i], dp[arr[0]] + arr[2]);\n            }\n        }\n        \n        return dp[max];\n        */\n        \n        \n        \n        \n        \n//         // treemap 126 ms, 8.96%\n//         int len = startTime.length;\n//         int[][] jobs = new int[len][3];\n//         for(int i=0; i<len; i++){\n//             jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n//         }\n//         Arrays.sort(jobs, (a,b) -> (a[1]-b[1]));\n        \n// //         TreeMap<Integer, Integer> map = new TreeMap<>(); // endTime, profit\n// //         map.put(0,0);\n// //         for(int i=0; i<len; i++){\n// //             int cur = map.floorEntry(jobs[i][0]).getValue() + jobs[i][2];\n// //             if(cur>map.lastEntry().getValue()){\n// //                 map.put(jobs[i][1], cur);\n// //             }\n// //         }\n// //         return map.lastEntry().getValue();\n        \n\n\n\n\n\n\n        \n        // dp +binarySearch 63ms, 49.86%\n        int len = startTime.length;\n        int[][] jobs = new int[len+1][3];\n        for(int i=0; i<len; i++){\n            jobs[i+1] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        Arrays.sort(jobs, (a,b) -> (a[1]-b[1]));\n        \n        int[] dp = new int[len+1];\n\n        for(int i=1; i<=len; i++){\n            dp[i] = Math.max( dp[i-1], jobs[i][2]);   //不做job, profit=i-1\n            int st=0, ed=i-1;\n            while(st<ed){\n                int m = ed-(ed-st)/2;\n\n                if(jobs[m][1]<= jobs[i][0]){ //找 \"前一個\"做完的profit : 檢查之前的job, 如果之前的edTime <= 現在的 stTime 就找到了\n                    st = m;\n                }else{\n                    ed = m-1;\n                }\n            }\n\n            // check time again\n            if(jobs[st][1]<= jobs[i][0]){\n                 dp[i] = Math.max(dp[i], dp[st]+jobs[i][2]);\n            }\n        }\n       \n        return dp[len];\n        \n        \n    }\n}","compare_result":"1111111111111111111111111111111111","title_slug":"maximum-profit-in-job-scheduling","has_notes":false,"flag_type":1}