{"id":1100682326,"question_id":1228,"lang":"java","lang_name":"Java","time":"6 months, 4 weeks","timestamp":1700212418,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1100682326/","is_pending":"Not Pending","title":"Minimum Cost Tree From Leaf Values","memory":"N/A","code":"class Solution {\n    public int mctFromLeafValues(int[] arr) {\n    {\n        List<Integer> list = new ArrayList<>();\n        for(int a: arr) list.add(a);\n        \n        int res = 0;\n        while(list.size() != 1)\n        {\n            int minIndex = list.indexOf(Collections.min(list));\n            \n            if(minIndex > 0 && minIndex < list.size()-1)\n                res += list.get(minIndex) * Math.min(list.get(minIndex-1), list.get(minIndex+1));   \n            \n            else if(minIndex == 0)\n                res += list.get(minIndex) * list.get(minIndex+1);\n            \n            else\n                res += list.get(minIndex) * list.get(minIndex-1);\n            \n            list.remove(minIndex);\n        }\n        return res;\n\n    }\n}\n\n/*\nsol stack\n\n[ x x1 x2 x x ] [x x x x x]\n\nx1 : [..a]\nx2 : [..b]\n\ncost = Math.max(a, b) 小的數字被刪除\n其實就是找cost = Math.min(prevGreater, nextGreater);\n相消之後不影響後續抉擇\n\n\n\nsol dp:\n\n[x x x x x] [x x x x j]\n i.      k\n\n dp[i][j] = min { max[i][k]*max[k+1][j] + dp[i][k] + dp[k+1][j] } over k : i~j\n\n*/\n\n\n\n/* \n\na b c\n\nabc + ab is smaller\n\n    c* Math.max(a,b)\n    / \\\n  ab   c \n  /\\    \n a  b \n\n\n a * Math.max(b,c)\n /.  \\\n a   bc\n    / \\\n   b   c\n\n\n\n*/","compare_result":null,"title_slug":"minimum-cost-tree-from-leaf-values","has_notes":false,"flag_type":1}