{"id":1100677958,"question_id":1228,"lang":"java","lang_name":"Java","time":"6 months, 4 weeks","timestamp":1700211864,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1100677958/","is_pending":"Not Pending","title":"Minimum Cost Tree From Leaf Values","memory":"N/A","code":"class Solution {\n    public int mctFromLeafValues(int[] arr) {\n        int len = arr.length;\n        if(len==1)\n            return 0;\n\n        int[] nextGreater = new int[len];\n        Arrays.fill(nextGreater, len);\n        Stack<Integer> st = new Stack<>();\n        for(int i=0; i<len; i++){\n\n            if(st.isEmpty() || arr[i] <= arr[st.peek()]){\n                st.push(i);\n                continue;\n            }\n            \n\n            while(!st.isEmpty() && arr[st.peek()]<=arr[i]){\n                nextGreater[st.pop()] = i;\n            }\n            st.push(i);\n        }\n\n        int[] prevGreater = new int[len];\n        Arrays.fill(prevGreater, -1);\n        st.clear();\n        for(int i=len-1; i>=0; i--){\n\n            if(st.isEmpty() || arr[i] <= arr[st.peek()]){\n                if(!st.isEmpty()){\n                    prevGreater[i] == arr[stack.pop()];\n                }\n\n\n                st.push(i);\n                continue;\n            }\n            \n            while(!st.isEmpty() && arr[st.peek()]<=arr[i]){\n                prevGreater[st.pop()] = i;\n            }\n            st.push(i);\n        }\n\n\n        int res = 1;\n        for(int i=0; i<len; i++){\n            \n            if(nextGreater[i]!=len && prevGreater[i]!=-1){\n                res *= Math.min(arr[nextGreater[i]],  arr[prevGreater[i]]);\n\n            }else if(nextGreater[i]!=len){\n                res *= arr[nextGreater[i]];\n\n            }else if(prevGreater[i]!=-1)\n                res *=arr[prevGreater[i]];\n        }\n\n        return res;\n\n\n    }\n}\n\n/*\nsol stack\n\n[ x x1 x2 x x ] [x x x x x]\n\nx1 : [..a]\nx2 : [..b]\n\ncost = Math.max(a, b) 小的數字被刪除\n其實就是找cost = Math.min(prevGreater, nextGreater);\n相消之後不影響後續抉擇\n\n\n\nsol dp:\n\n[x x x x x] [x x x x j]\n i.      k\n\n dp[i][j] = min { max[i][k]*max[k+1][j] + dp[i][k] + dp[k+1][j] } over k : i~j\n\n*/\n\n\n\n/* \n\na b c\n\nabc + ab is smaller\n\n    c* Math.max(a,b)\n    / \\\n  ab   c \n  /\\    \n a  b \n\n\n a * Math.max(b,c)\n /.  \\\n a   bc\n    / \\\n   b   c\n\n\n\n*/","compare_result":null,"title_slug":"minimum-cost-tree-from-leaf-values","has_notes":false,"flag_type":1}