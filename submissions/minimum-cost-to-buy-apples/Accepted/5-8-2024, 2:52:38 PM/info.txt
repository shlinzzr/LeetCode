{"id":1252426583,"question_id":2612,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1715151158,"status":10,"status_display":"Accepted","runtime":"681 ms","url":"/submissions/detail/1252426583/","is_pending":"Not Pending","title":"Minimum Cost to Buy Apples","memory":"46.6 MB","code":"class Solution {\n    public long[] minCost(int n, int[][] roads, int[] appleCost, int k) {\n\n        Map<Integer, Map<Integer, Integer>> adjs = new HashMap<>();\n        buildMap(roads, adjs);\n        long[] res= new long[n];\n\n        LinkedHashMap<String, Long >memo = new LinkedHashMap<>();\n\n        for(int start=1; start<=n; start++){\n            boolean[] seen = new boolean[n+1];\n            seen[start]=true;\n            // long rt = dfs(start, 0L, adjs, appleCost, k, seen, memo);\n            long rt = dijkstra(start, adjs, appleCost, k);\n            res[start-1] = rt;\n        }\n\n        return res;\n        \n    }\n\n    private long dijkstra(int start, Map<Integer, Map<Integer, Integer>> adjs, int[] appleCost, int k){\n        long ans = appleCost[start-1];\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>( // idx, costSum\n            (a, b) -> a[1] - b[1]\n        );\n\n        Set<Integer> seen = new HashSet<>();\n        pq.offer(new int[]{start, 0});\n\n        while(!pq.isEmpty()){\n            int size = pq.size();\n            while(size-->0){\n                int[] p = pq.poll();\n\n                seen.add(p[0]);\n\n                ans = Math.min(ans, (k+1L)*p[1] + appleCost[p[0]-1] );\n\n                Map<Integer, Integer> adjMap = adjs.getOrDefault(p[0], new HashMap<>());\n                for(int key : adjMap.keySet()){\n                    if(seen.contains(key)) continue;\n                    pq.offer(new int[]{key, p[1]+adjMap.get(key)});\n                }\n            }\n        }\n\n        return ans;\n\n\n    }\n\n\n    // TLE : using prorityQueue to fix this\n    // private long dfs(int curr, long acc,  Map<Integer, Map<Integer, Integer>> adjs \n    // , int[] appleCost, int k, boolean[] seen, LinkedHashMap<String, Long> memo ){\n\n    //     if(memo.containsKey(curr+\"_\"+memo.keySet().toString()))\n    //         return memo.get(curr+\"_\"+memo.keySet().toString());\n        \n    //     int takeApple = appleCost[curr-1];\n\n    //     // return @ curr \n    //     long res = acc + takeApple + k*acc;\n\n\n    //     Map<Integer, Integer> nebs = adjs.getOrDefault(curr, new HashMap<>());\n    //     for(int neb : nebs.keySet()){\n    //         if(seen[neb]) continue;\n    //         seen[neb] = true;\n    //         long roadCost = (long)nebs.get(neb);\n\n    //         long rt = dfs(neb, acc+roadCost, adjs, appleCost, k, seen, memo);\n\n    //         // System.out.println(curr+ \"->\" + neb + \"=\" + rt);\n\n    //         res = Math.min(res, rt);\n    //         seen[neb] = false;\n    //     }\n\n    //     memo.put(curr+\"_\"+memo.keySet().toString(), res);\n    //     return res;\n    // }\n\n    private void buildMap(int[][] roads, Map<Integer, Map<Integer, Integer>> adjs ){\n\n        int len = roads.length;\n        for(int[] r : roads){\n            int a = r[0];\n            int b = r[1] ;\n            int cost = r[2];\n\n            adjs.putIfAbsent(a, new HashMap<>());\n            adjs.get(a).put(b, cost);\n            adjs.putIfAbsent(b, new HashMap<>());\n            adjs.get(b).put(a, cost);\n        }\n\n    }\n}","compare_result":"111111111111111111111111111111111111111","title_slug":"minimum-cost-to-buy-apples","has_notes":false,"flag_type":1}