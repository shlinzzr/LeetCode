{"id":1284764480,"question_id":2353,"lang":"java","lang_name":"Java","time":"1 day, 16 hours","timestamp":1718100555,"status":10,"status_display":"Accepted","runtime":"60 ms","url":"/submissions/detail/1284764480/","is_pending":"Not Pending","title":"Maximum Score of a Node Sequence","memory":"71.2 MB","code":"class Solution {\n\n    public int maximumScore(int[] A, int[][] edges) {\n           int n = A.length;\n        PriorityQueue<Integer>[] q = new PriorityQueue[n];//Array of PQ\n        for (int i = 0; i < n; i++)\n            q[i] = new PriorityQueue<>((a, b) -> A[a] - A[b]); //Add PQ for every edge i. Sort PQ by score of edge i\n        for (int[] e : edges) {\n            q[e[0]].offer(e[1]); //add j to PQ of i\n            q[e[1]].offer(e[0]); //add i to PQ of j\n            if (q[e[0]].size() > 3) q[e[0]].poll(); //If edges are more than 3 then remove the edge with least score\n            if (q[e[1]].size() > 3) q[e[1]].poll(); //If edges are more than 3 then remove the edge with least score\n        }\n        int res = -1;\n        for (int[] edge : edges) // for every edge (a,b)\n            for (int i : q[edge[0]]) // for every connecting edge with a (we are fetching this from PQ)\n                for (int j : q[edge[1]])//for every connecting edge with b (we are fetching this from PQ)\n                    if (i != j && i != edge[1] && j != edge[0])//if no duplicate in combo of these 4\n                        res = Math.max(res, A[i] + A[j] + A[edge[0]] + A[edge[1]]);  // update the max score for this 4 combo\n        return res;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-score-of-a-node-sequence","has_notes":false,"flag_type":1}