{"id":1095821710,"question_id":675,"lang":"java","lang_name":"Java","time":"7Â months","timestamp":1699607600,"status":10,"status_display":"Accepted","runtime":"391 ms","url":"/submissions/detail/1095821710/","is_pending":"Not Pending","title":"Cut Off Trees for Golf Event","memory":"44.6 MB","code":"class Solution {\n\n    int[][] dirs = new int[][]{{0,1}, {1,0}, {0,-1}, {-1,0}};\n\n    public int cutOffTree(List<List<Integer>> forest) {\n\n        if(forest.get(0).get(0)==0)\n            return -1;\n\n        int m = forest.size();\n        int n = forest.get(0).size();\n\n        if(forest.get(0).get(0)==0)\n            return -1;\n\n        if(m*n==1)\n            return 0;\n\n        Queue<int[]> q = new LinkedList<>();\n        PriorityQueue<int[]> pq = new PriorityQueue<>( // r, c, val\n            (a,b) -> a[2]-b[2]\n        );\n        boolean[][] seen = new boolean[m][n];\n\n        pq.offer(new int[]{0,0,forest.get(0).get(0)});\n        q.offer(new int[]{0,0});\n        seen[0][0]=true;\n        int step=0;\n\n       \n        while(!q.isEmpty()){\n\n            int siz = q.size();\n            while(siz-->0){\n                int[] p = q.poll();\n\n                for(int[] d: dirs){\n                    int r = d[0]+p[0];\n                    int c = d[1]+p[1];\n                    \n                    if(r<0 || c<0 || r>=m || c>=n || seen[r][c] || forest.get(r).get(c)==0 ){\n                        continue;\n                    }\n                    seen[r][c]=true;\n                    q.offer(new int[]{r,c});\n                    if(forest.get(r).get(c)!=1)\n                        pq.offer(new int[]{r,c,forest.get(r).get(c)});\n                }\n            }\n        }\n\n\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(forest.get(i).get(j)>0 && seen[i][j]==false)\n                    return -1;\n            }\n        }\n\n        int path=0;\n        int[] cur= new int[]{0,0};\n        while(!pq.isEmpty()){\n            int[] nxt = pq.poll();\n                \n            path += findShortestPath(forest, cur, nxt);\n\n            System.out.println(nxt[0] + \",\" + nxt[1] + \" val=\" + nxt[2] + \" path=\"+path);\n            cur = nxt;\n        }\n\n        return path;\n\n    }\n\n\n    private int findShortestPath(List<List<Integer>> forest, int[] src, int[] dest){\n        if(src[0]==dest[0] && src[1]==dest[1])\n            return 0;\n\n        int m = forest.size();\n        int n = forest.get(0).size();\n\n\n        boolean[][] seen = new boolean[m][n];\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(src);\n        seen[src[0]][src[1]] = true;\n        int step = 1;\n        while(!q.isEmpty()){\n            int siz=q.size();\n\n            while(siz-->0){\n                int[] p = q.poll();\n\n                for(int[] d: dirs){\n\n                    int r = d[0]+p[0];\n                    int c = d[1]+p[1];\n                    if(r<0 || c<0 || r>=m || c>=n || seen[r][c] || forest.get(r).get(c)==0 ){\n                        continue;\n                    }\n\n                    if(r==dest[0] && c==dest[1])\n                        return step;\n\n                    seen[r][c]=true;\n                    q.offer(new int[]{r,c});\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n}\n\n/*\n[[4,2,3]\n,[0,0,1]\n,[7,6,5]]\n\n\n[[4557,6199,7461,2554,6132,7471,7103,4290]\n,[2034,2301,6733,6040,2603,5697,9541,6678]\n,[7308,7368,9618,4386,6944,3923,4754,4294]\n,[xxxx,3016,7242,5284,6631,1897,1767,7603]\n,[2228,xxxx,3625,7713,2956,3264,3371,6124]\n,[9195,7804,2787,xxxx,4919,9304,5161,502]]\n*/","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"cut-off-trees-for-golf-event","has_notes":false,"flag_type":1}