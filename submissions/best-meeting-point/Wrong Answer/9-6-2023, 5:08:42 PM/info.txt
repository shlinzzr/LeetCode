{"id":1041983524,"question_id":296,"lang":"java","lang_name":"Java","time":"9 months, 1 week","timestamp":1693991322,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1041983524/","is_pending":"Not Pending","title":"Best Meeting Point","memory":"N/A","code":"class Solution {\n    public int minTotalDistance(int[][] grid) {\n        HashSet<int[]> set = new HashSet<>();\n        int[] h = getHouse(grid, set);\n        \n        // System.out.println(h[0] + \" \" + h[1]);\n        \n        int res = 0 ;\n        for(int[] b : set){\n            res += Math.abs(h[0]-b[0]) + Math.abs(h[1]-b[1]);\n        }\n        \n        \n        return res;         \n    }\n    \n     \n    private int[] getHouse(int[][] grid, HashSet<int[]> buildings){\n        int h = grid.length;\n        int w = grid[0].length;\n        \n        boolean[][][][] seen = new boolean[h][w][h][w]; // seen[i][j][k][l] 以i j出發的有沒有走過k l\n        \n        Queue<int[]> q= new LinkedList<>();\n        \n        int emptyLand = 0;\n        \n        for(int i=0; i<h;i++){\n            for(int j=0; j<w; j++){\n                \n                if(grid[i][j]==1){\n                    buildings.add(new int[]{i, j});\n                    q.offer(new int[]{i, j, i, j}); // 從i j 出發的 目前走到i j\n                    seen[i][j][i][j] = true;   \n                }else if(grid[i][j]==2){\n                    grid[i][j]=-1;\n                }else\n                    emptyLand++;\n            }\n        }\n        \n        // if(emptyLand==0)\n        //     return null;\n        \n        int[][] dirs = new int[][]{{0,1}, {1,0}, {0,-1}, {-1,0}};\n        \n        int[] house = null;\n        \n        int step = 0;\n        while(!q.isEmpty()){\n            int siz = q.size();\n            \n            while(siz-->0){\n                \n                int[] p = q.poll();\n                \n                for(int[] d: dirs){\n                    \n                    int i = p[0];\n                    int j = p[1];\n                    int k = d[0]+p[2];\n                    int l = d[1]+p[3];\n                    \n                    \n                    if(k<0 || l<0 || k>=h || l>=w || seen[i][j][k][l] || grid[k][l]==-1)\n                        continue;\n                    \n                    grid[k][l]++;\n                    // System.out.println(i+\" \"+j + \" \" + k + \" \" + l + \" grid[k][l]=\"+grid[k][l] + \" building=\"+buildings.size());\n                    \n                    if(grid[k][l]==buildings.size()){\n                        house = new int[]{k, l};    \n                        return house;\n                    }\n                    \n                    seen[i][j][k][l] = true;\n                    q.offer(new int[]{i,j, k, l});\n                }\n            }\n            step++;\n        }\n        \n        return house;\n    }\n    \n}","compare_result":"1111111111000000000000000010000000010000000000000000001100","title_slug":"best-meeting-point","has_notes":false,"flag_type":1}