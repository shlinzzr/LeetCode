{"id":1251429970,"question_id":895,"lang":"java","lang_name":"Java","time":"1Â month","timestamp":1715056137,"status":10,"status_display":"Accepted","runtime":"107 ms","url":"/submissions/detail/1251429970/","is_pending":"Not Pending","title":"Shortest Path to Get All Keys","memory":"55.3 MB","code":"class Solution {\n    public int shortestPathAllKeys(String[] grid) {\n\n        int h = grid.length;\n        int w = grid[0].length();\n        \n        Queue<int[]> queue = new LinkedList<>();\n        \n        int lock = 0;\n        \n        int[] start = new int[3]; // r, c, curr keys\n        \n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                char ch = grid[i].charAt(j);\n                if(ch=='@'){\n                    start[0]=i;\n                    start[1]=j;\n                }else if(ch>='A' && ch<='F'){\n                    lock |= (1<<(ch-'A'));\n                }\n            }\n        }\n        \n        queue.offer(start);\n        Set<String> visited = new HashSet<>();\n        visited.add(start[0] + \" \" + start[1] + \" \" + start[2]);\n\n        int step = 0;\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                int[] p = queue.poll();\n                \n                for (int[] d : dirs) {\n                    int i = p[0] + d[0];\n                    int j = p[1] + d[1];\n                    int keys = p[2];\n                    \n                    if (i < 0 || i >= h || j < 0 || j >= w) continue;                   // out of grid\n                    char ch = grid[i].charAt(j);\n\n                    if (ch == '#') continue;                                             // wall\n                    if ('A' <= ch && ch <= 'F' && ((p[2] >> (ch-'A')) & 1) == 0) continue; // meet lock without key = wall\n                    if ('a' <= ch && ch <= 'f') keys = p[2] | (1 << (ch-'a'));             // update key\n                    if (visited.contains(i + \" \" + j + \" \" + keys)) continue;           // visited\n                    if (keys == lock) return step+1;                                   // all found !!!\n                    visited.add(i + \" \" + j + \" \" + keys );\n                    queue.offer(new int[] {i, j, keys});\n                }\n            }\n            step++;\n        }\n\n        return -1; // not found\n    }\n}","compare_result":"11111111111111111111111111111111111","title_slug":"shortest-path-to-get-all-keys","has_notes":false,"flag_type":1}