{"id":1100608667,"question_id":2111,"lang":"java","lang_name":"Java","time":"6 months, 4 weeks","timestamp":1700203366,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1100608667/","is_pending":"Not Pending","title":"Binary Searchable Numbers in an Unsorted Array","memory":"N/A","code":"class Solution {\n    public int binarySearchableNumbers(int[] nums) {\n        int len = nums.length;\n\n        Stack<Integer> st = new Stack<>();\n\n        int[] prevGreater = new int[len];\n        Arrays.fill(prevGreater, -1);\n        for(int i=len-1; i>=0; i--){\n            while(!st.isEmpty() && nums[st.peek()]>nums[i]){\n                prevGreater[st.pop()] = i;\n            }\n            st.push(i);\n        }\n\n        int[] nextSmaller = new int[len];\n        Arrays.fill(nextSmaller, len);\n        for(int i=0; i<len; i++){\n            while(!st.isEmpty() && nums[st.peek()]>nums[i]){\n                nextSmaller[st.pop()] = i;\n            }\n            st.push(i);\n        }\n\n        int res = 0;\n        for(int i=0; i<len; i++){\n            if(nextSmaller[i]==len && prevGreater[i]==-1){\n                res++;\n            }\n        }\n        return res;\n        \n    }\n}\n\n\n/*\n\n\nx x x x x x t x x x \n      ^\n- - - - x x t x x x\n\n\n当pivot < target时，会将pivot左侧的数都抹去。此时如果抹去的数字里有比pivot大的数字，那么它将永远不会被找到。有人会问，被抹去的数字里那些比pivot小的不同样永远无法搜到了吗？但是没有关系，因为我们的target大于pivot，说明我们不关心那些比pivot小的数字（他们不是我们的搜索目标）。因此，我们得出结论，对于任意一个数nums[i]，如果它的prevGreater存在，那么当nums[i]被选为pivot时，那个prevGreater就会无法被该算法搜到。\n\n同理，当pivot > target时，会将pivot右侧的数都抹去。此时如果抹去的数字里有比pivot小的数字，那么它将永远不会被找到。同样，我们不关心那些比pviot大的数字是否被抹掉（因为它们不是我们的搜索目标）。因此我们有类似的结论，对于任意一个数nums[i]，如果它的nextSmaller存在，那么当nums[i]被选为pivot时，那个nextSmaller就会无法被该算法搜到。\n\n我们提前用两轮单调栈，用o(N)的时间把每个元素的prevGreater和nextSmaller都找到。只有同时不存在prevGreater和nextSmaller的那些数，才能保证被算法搜索到。\n\n*/","compare_result":"1101000000000000000000000000000000100000000000000000000000100","title_slug":"binary-searchable-numbers-in-an-unsorted-array","has_notes":false,"flag_type":1}