{"id":1241544870,"question_id":1134,"lang":"java","lang_name":"Java","time":"1 month, 2 weeks","timestamp":1714037618,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1241544870/","is_pending":"Not Pending","title":"Shortest Distance to Target Color","memory":"N/A","code":"class Solution {\n    public List<Integer> shortestDistanceColor(int[] colors, int[][] queries) {\n        Stack<Integer> st = new Stack<>();\n        \n        int len = colors.length;\n        \n        \n        int[] nextGreater = new int[len];\n        Arrays.fill(nextGreater, Integer.MAX_VALUE);\n        \n        for(int i=0; i<colors.length; i++){\n            while(!st.isEmpty() && colors[st.peek()]<colors[i]){\n                nextGreater[st.pop()] = i;\n            }\n            st.push(i);\n        }\n        \n        // for(int i=0; i<nextGreater.length; i++){\n        //     System.out.print(nextGreater[i] + \",\");\n        // }\n        // System.out.println();\n        \n        st.clear();\n        int[] prevGreater = new int[len];\n        Arrays.fill(prevGreater, Integer.MIN_VALUE);\n        for(int i=len-1; i>=0 ; i--){\n            while(!st.isEmpty() && colors[st.peek()] < colors[i]){\n                prevGreater[st.pop()] = i;\n            }\n            st.push(i);\n        }\n        // for(int i=0; i<prevGreater.length; i++){\n        //     System.out.print(prevGreater[i] + \",\");\n        // }\n        // System.out.println();\n        \n        \n        st.clear();\n        int[] nextSmaller = new int[len];\n        Arrays.fill(nextSmaller, Integer.MAX_VALUE);\n        for(int i=0; i<colors.length; i++){\n            while(!st.isEmpty() && colors[st.peek()]>colors[i]){\n                nextSmaller[st.pop()] = i;\n            }\n            st.push(i);\n        }\n        //  for(int i=0; i<nextSmaller.length; i++){\n        //     System.out.print(nextSmaller[i] + \",\");\n        // }\n        // System.out.println();\n        \n        st.clear();\n        int[] prevSmaller = new int[len];\n        Arrays.fill(prevSmaller, Integer.MIN_VALUE);\n        for(int i=len-1; i>=0 ; i--){\n            while(!st.isEmpty() && colors[st.peek()] > colors[i]){\n                prevSmaller[st.pop()] = i;\n            }\n            st.push(i);\n        }\n        \n//          for(int i=0; i<prevSmaller.length; i++){\n//             System.out.print(prevSmaller[i] + \",\");\n//         }\n//         System.out.println();\n        \n        \n        \n        int[] res = new int[queries.length];\n        \n        for(int i=0; i<queries.length; i++){\n            int[] q = queries[i];\n            int idx = q[0];\n            int targetColor = q[1];\n            int currentColor = colors[idx];\n            \n            if(targetColor==currentColor){\n                res[i] = 0;\n            }else if(targetColor>currentColor){\n                \n                \n                \n                int next = (targetColor-currentColor==2) ? \n                    (nextGreater[idx]==Integer.MAX_VALUE? Integer.MAX_VALUE : nextGreater[nextGreater[idx]]) : nextGreater[idx];\n                int prev = (targetColor-currentColor==2) ? \n                    (prevGreater[idx]==Integer.MIN_VALUE? Integer.MIN_VALUE : prevGreater[prevGreater[idx]]) : prevGreater[idx];\n                \n                if(i==0){\n                    System.out.println(next + \" \" + prev); \n                }\n                \n                if(next==Integer.MAX_VALUE && prev==Integer.MIN_VALUE) \n                    res[i]=-1;\n                else if(next!=Integer.MAX_VALUE && prev==Integer.MIN_VALUE)\n                    res[i] = next-idx;\n                    \n                else if(next==Integer.MAX_VALUE && prev!=Integer.MIN_VALUE)\n                    res[i] = idx-prev;\n                else \n                    res[i] = Math.min(next-idx, idx-prev);\n                \n            }else{\n                int next = (currentColor-targetColor==2) ? \n                    (nextSmaller[idx]==Integer.MAX_VALUE ? Integer.MAX_VALUE : nextSmaller[nextSmaller[idx]]) : nextSmaller[idx];\n                int prev = (currentColor-targetColor==2) ? \n                    (prevSmaller[idx]==Integer.MIN_VALUE ? Integer.MIN_VALUE : prevSmaller[prevSmaller[idx]]) : prevSmaller[idx];\n                    \n                if(next==Integer.MAX_VALUE && prev==Integer.MIN_VALUE) \n                    res[i]=-1;\n                else if(next!=Integer.MAX_VALUE && prev==Integer.MIN_VALUE)\n                    res[i] = next-idx;\n                    \n                else if(next==Integer.MAX_VALUE && prev!=Integer.MIN_VALUE)\n                    res[i] = idx-prev;\n                else \n                    res[i] = Math.min(next-idx, idx-prev);\n                \n            }\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        for(int i=0; i<res.length; i++){\n            list.add(res[i]);\n        }\n        \n        return list;\n        \n        \n        \n    }\n}","compare_result":"11100000000000000011","title_slug":"shortest-distance-to-target-color","has_notes":false,"flag_type":1}