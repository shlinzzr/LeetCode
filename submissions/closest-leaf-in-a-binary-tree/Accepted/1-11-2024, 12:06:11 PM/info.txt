{"id":1142974824,"question_id":743,"lang":"java","lang_name":"Java","time":"5Â months","timestamp":1704945971,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1142974824/","is_pending":"Not Pending","title":"Closest Leaf in a Binary Tree","memory":"44.1 MB","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    Map<TreeNode, List<TreeNode>> g = new HashMap<>();\n    public int findClosestLeaf(TreeNode root, int k) {\n\n        \n        List<TreeNode> leaves = new ArrayList<>();\n        findAllLeaves(null, root, leaves);\n        HashSet<TreeNode> seen = new HashSet<>();\n        Queue<TreeNode[]> q = new LinkedList<>();\n        for(TreeNode t : leaves){\n            q.offer(new TreeNode[]{t, t}); // org, cur\n            seen.add(t);\n        }\n\n        // System.out.println()\n\n\n        \n\n        int step = 0;\n        while(!q.isEmpty()){\n            int siz = q.size();\n            while(siz-->0){\n\n                TreeNode[] p = q.poll();\n                if(p[1].val==k) {\n                    return p[0].val;\n                }\n\n                for(TreeNode next : g.get(p[1])){\n                    if(seen.contains(next)) continue;\n                    q.offer(new TreeNode[]{p[0], next});\n                    seen.add(next);\n                }\n            }\n        }\n\n        return -1;\n        \n    }\n\n    private void findAllLeaves(TreeNode parent, TreeNode node, List<TreeNode> leaves){\n        if(node==null) return;\n\n        g.putIfAbsent(node, new ArrayList<>());\n        if(parent!=null) g.get(node).add(parent);\n        if(node.left!=null) g.get(node).add(node.left);\n        if(node.right!=null) g.get(node).add(node.right);\n\n        if(node.left==null && node.right==null)\n            leaves.add(node);\n        else{\n            findAllLeaves(node, node.left, leaves);\n            findAllLeaves(node ,node.right, leaves);\n        }\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"closest-leaf-in-a-binary-tree","has_notes":false,"flag_type":1}