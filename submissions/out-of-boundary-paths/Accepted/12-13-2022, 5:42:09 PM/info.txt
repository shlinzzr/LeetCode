{"id":859089695,"question_id":576,"lang":"java","lang_name":"Java","time":"1 year, 6 months","timestamp":1670924529,"status":10,"status_display":"Accepted","runtime":"33 ms","url":"/submissions/detail/859089695/","is_pending":"Not Pending","title":"Out of Boundary Paths","memory":"42.9 MB","code":"public class Solution {\n    public int findPaths(int m, int n, int N, int i, int j) {\n        if (N <= 0) return 0;\n        \n        final int MOD = 1000000007;\n        int[][] count = new int[m][n];\n        count[i][j] = 1;\n        int result = 0;\n        \n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        for (int step = 0; step < N; step++) {\n            int[][] temp = new int[m][n];\n            for (int r = 0; r < m; r++) {\n                for (int c = 0; c < n; c++) {\n                    for (int[] d : dirs) {\n                        int nr = r + d[0];\n                        int nc = c + d[1];\n                        if (nr < 0 || nr >= m || nc < 0 || nc >= n) {\n                            result = (result + count[r][c]) % MOD;\n                        }\n                        else {\n                            temp[nr][nc] = (temp[nr][nc] + count[r][c]) % MOD;\n                        }\n                    }\n                }\n            }\n            count = temp;\n        }\n        \n        return result;\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"out-of-boundary-paths","has_notes":false,"flag_type":1}