{"id":987618290,"question_id":2498,"lang":"java","lang_name":"Java","time":"11 months, 1 week","timestamp":1688632036,"status":10,"status_display":"Accepted","runtime":"36 ms","url":"/submissions/detail/987618290/","is_pending":"Not Pending","title":"Smallest Subarrays With Maximum Bitwise OR","memory":"64.8 MB","code":"class Solution {\n    public int[] smallestSubarrays(int[] nums) {\n       \n        //https://www.youtube.com/watch?v=npZ4NlpomeU\n        \n        // 難 概念有 不好實做\n        \n        \n        int len = nums.length;\n        int ed = len-1;\n        int[] res = new int[len];\n        int[] arr = new int[32];\n        \n        \n        for (int st=len-1; st>=0; st--)\n        {\n            for (int k=0; k<32; k++){\n                arr[k] += ((nums[st]>>k)&1);\n            }\n                \n            \n            while (ed>st && isOK(nums[ed], arr))\n            {\n                for (int k=0; k<32; k++)\n                    arr[k] -= ((nums[ed]>>k)&1);\n                ed--;\n            }\n            \n            res[st] = ed-st+1;\n        }\n        return res;\n        \n    }\n    \n    private boolean isOK(int num, int[] arr) { //ed可以往左移, 等於最後一位有沒有or 對sum 沒有影響\n        for (int k=0; k<32; k++) {\n            if (arr[k] > 0 && (arr[k] - ((num>>k)&1) <= 0)) \n                return false;\n        }\n        return true;\n    }\n    \n}","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-subarrays-with-maximum-bitwise-or","has_notes":false,"flag_type":1}