{"id":901320495,"question_id":922,"lang":"java","lang_name":"Java","time":"1 year, 3 months","timestamp":1676866719,"status":10,"status_display":"Accepted","runtime":"39 ms","url":"/submissions/detail/901320495/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"50.1 MB","code":"class Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {    \n        Map<Integer, Set<Integer>> graph = buildGraph(dislikes, n);\n        \n        // for(Map.Entry<Integer, Set<Integer>> en : graph.entrySet()){\n        //     System.out.println(en.getKey() + \" \" + en.getValue());\n        // }\n        \n        \n        UnionFind uf = new UnionFind(n);\n\n        for(int i = 1; i < n+1; i++) {\n            Set<Integer> neighbors = graph.get(i);\n            if(neighbors.size() == 0) continue;\n            int firstNeighbor = neighbors.iterator().next(); // gets the first item in the set\n\n            for(int neighbor : neighbors) {\n                if(uf.isConnected(i, neighbor)) return false; // if vertex i is connected with any of its neighbors, graph is not bipartite\n                uf.union(firstNeighbor, neighbor); // unionize all its neighbors\n            }\n        }\n\n        return true;\n    }\n  \n    public Map<Integer, Set<Integer>> buildGraph(int[][] edges, int n) {\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\n\n        for(int i = 1; i < n+1; i++) \n            graph.put(i, new HashSet<>());\n\n        for(int[] edge : edges) {\n            int src = edge[0];\n            int dest = edge[1];\n  \n            graph.get(src).add(dest);\n            graph.get(dest).add(src);\n        }\n        return graph;\n    }\n  \n  class UnionFind {\n    int[] parent;\n    int[] rank;\n    \n    public UnionFind(int n) {\n      parent = new int[n+1];\n      rank = new int[n+1];\n      \n      for(int i = 0; i < n+1; i++) {\n        parent[i] = i;\n      }\n    }\n    \n    public void union(int x, int y) {\n      int rootX = find(x);\n      int rootY = find(y);\n      \n         // System.out.println(\"union \"+ x + \", \" + y + \" rx=\"+rootX + \" ry=\"+rootY);\n        \n        \n      if(rootX != rootY) {\n        if(rank[rootX] > rank[rootY]) {\n          rank[rootX]++;\n          parent[rootY] = rootX;\n        } else {\n          rank[rootY]++;\n          parent[rootX] = rootY;\n        }\n      }\n        \n        \n//         for(int i=0; i<rank.length; i++){\n//             System.out.print(rank[i] + \", \");\n//         }\n//         System.out.println();\n        \n//         for(int i=0; i<parent.length; i++){\n//             System.out.print(parent[i] + \", \");\n//         }\n//         System.out.println();\n        \n        \n    }\n    \n    public int find(int x) {\n        \n        // System.out.println(\"parent[x]=\"+ parent[x] + \" x=\" + x);\n        \n        if(parent[x] == x) return x;\n      \n        int root = find(parent[x]);\n        parent[x] = root; //path compression\n        return root;\n    } \n    \n    public boolean isConnected(int x, int y) {\n        // System.out.println(\"isConnected \"+ x + \", \" + y);\n        \n        int fx = find(x);\n        int fy = find(y);\n        \n        // System.out.println(\"findx=\"+fx + \" findy=\" + fy);\n      return fx == fy;\n    }\n  }\n}\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false,"flag_type":1}