{"id":1253455092,"question_id":2259,"lang":"java","lang_name":"Java","time":"1 month","timestamp":1715250204,"status":10,"status_display":"Accepted","runtime":"99 ms","url":"/submissions/detail/1253455092/","is_pending":"Not Pending","title":"Minimum Operations to Remove Adjacent Ones in Matrix","memory":"91.4 MB","code":"class Solution {\n\n    // ref : 1820\n\n    int[][] dirs = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n    public int minimumOperations(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        \n        //1. 先建關係圖 buildMap\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\n\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(grid[i][j]==1){\n                    map.putIfAbsent(i*n+j, new ArrayList<>());\n\n                    for(int[] d : dirs){\n                        int r = i+d[0];\n                        int c = j+d[1];\n                        if(r<0 || c<0 || r>=m || c>=n || grid[r][c]!=1) continue;\n                        // seen.add(r*n+c);\n                        map.get(i*n+j).add(r*n+c);\n                    }\n                }\n            }\n        }\n\n\n        //準備匈牙利色色法 這邊用map或是int[h*w]都可以\n        HashMap<Integer, Integer> match = new HashMap<>();// girlFixed\n        int cnt = 0;\n        \n        for(int i=0; i<m*n; i++){ //男生從0~h*w都要試\n            if(match.containsKey(i)) continue; //之前配好的我不管, 如果不continue會重複算到\n\n            HashSet<Integer> seen = new HashSet<>();\n            if(dfs(i, map, match, seen)){\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n\n    private boolean dfs(int cur, HashMap<Integer,List<Integer>> map, HashMap<Integer, Integer> match , HashSet<Integer> seen){\n        for(int next : map.getOrDefault(cur, new ArrayList<>())){\n            if(!seen.contains(next)){\n                seen.add(next);\n                if(!match.containsKey(next) || dfs(match.get(next), map, match, seen)){\n                    match.put(next, cur); // A->B\n                    match.put(cur, next); // B->A 兩種狀況一樣 只做一次 不重複做了\n                    return true;\n                }\n            }\n        }\n\n        return false;\n\n\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-operations-to-remove-adjacent-ones-in-matrix","has_notes":false,"flag_type":1}