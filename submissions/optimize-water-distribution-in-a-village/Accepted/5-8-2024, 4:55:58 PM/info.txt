{"id":1252501920,"question_id":1144,"lang":"java","lang_name":"Java","time":"1 month","timestamp":1715158558,"status":10,"status_display":"Accepted","runtime":"92 ms","url":"/submissions/detail/1252501920/","is_pending":"Not Pending","title":"Optimize Water Distribution in a Village","memory":"54.7 MB","code":"class Solution {\n    \n/*\n直接跑prim's 會失敗的case 在於\nn = 5\nwells = [46012,72474,64965,751,33304]\npipes = [[2,1,6719],[3,2,75312],[5,3,44918]]\n注意這個圖 並沒有全部聯通 只有給 1 2 3 5\n這樣在choose完所有edge後 還要檢查每個vertex有沒有井水 \n發現4沒有給井水; 1,2,3,5還要自己判斷 min_well\n每個單獨的component都要給一個min well 很難處理\n*/\n\n    // Prim's\n    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {\n        \n        Map<Integer, Map<Integer,Integer>> map = new HashMap<>();\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (a[1] - b[1])); //idx, cost\n        // Prim's algo : start from any node, let's start from virtual vertex zero :\n        // we create the virtual vertex 0 with the cost with wells\n        // start from vertex zero\n        // always choosing the min edge from map\n\n        // buildGraph from pipes\n        buildGraph(pipes, map);\n\n        // create virtual vertex zero\n        map.put(0, new HashMap<>());\n        for(int i=0; i<wells.length; i++){\n            map.get(0).put(i+1, wells[i]); //wells是 1-idx\n\n            pq.offer(new int[]{i+1, wells[i]}); // start from 0's adj;\n        }\n\n        Set<Integer> seen = new HashSet<>();\n        seen.add(0);\n\n        int currCost = 0;\n        while(!pq.isEmpty()){\n            int size =pq.size();\n            while(size-->0){\n\n                int[] p = pq.poll();\n                int idx = p[0];\n                int pipeCost = p[1];\n\n                if(seen.contains(idx)) continue;\n                seen.add(idx);\n                currCost += pipeCost;\n\n                Map<Integer,Integer> adjs = map.getOrDefault(idx, new HashMap<>());\n                for(int k : adjs.keySet()){\n                    if(seen.contains(k)) continue;\n                    pq.offer(new int[]{k, adjs.get(k)});\n                }\n            }\n        }\n\n        return currCost;\n\n\n\n    }\n\n\n    private void buildGraph(int[][] pipes, Map<Integer, Map<Integer,Integer>> map ){\n\n        for(int[] p : pipes){\n            int a = p[0];\n            int b = p[1];\n            int c = p[2];\n\n            map.putIfAbsent(a, new HashMap<>());\n            if(!map.get(a).containsKey(b) || map.get(a).get(b)>c)\n                map.get(a).put(b, c);\n\n            map.putIfAbsent(b, new HashMap<>());\n            if(!map.get(b).containsKey(a) || map.get(b).get(a)>c)\n                map.get(b).put(a, c);\n        }\n\n    }\n}","compare_result":"1111111111111111111111111111111111111111","title_slug":"optimize-water-distribution-in-a-village","has_notes":false,"flag_type":1}