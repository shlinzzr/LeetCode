{"id":79284752,"question_id":409,"lang":"c","lang_name":"C","time":"7 years, 7 months","timestamp":1476956736,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/79284752/","is_pending":"Not Pending","title":"Longest Palindrome","memory":"N/A","code":"//char *s => A = 65  , a = 97\r\n//  *s - 'a' = 0\r\n\r\nint longestPalindrome(char* s) {\r\n    \r\n    bool haveodd= false;\r\n    int result,tmp,cnt = 0;\r\n    int n = strlen(s);\r\n    int *arr = malloc(52*sizeof(int));  //a-z A-Z\r\n    for(int i=0;i<n;i++)\r\n    {\r\n      int num = *(s+i) -'A';\r\n      printf(\"%d \", 'A');\r\n      arr[ num ]++;\r\n    }\r\n    \r\n    for(int j=0;j<52;j++)\r\n    {\r\n        \r\n        if(arr[j]%2==1){\r\n            haveodd =true;\r\n            cnt++;\r\n        }\r\n    }\r\n    \r\n    if(haveodd) return n-cnt+1;\r\n    \r\n    return n;\r\n} \r\n/*    \r\n    while(*s)\r\n    {\r\n        printf(\"s=%d \",*s-'a'+1);\r\n        result=result^(*s++ -'a' + 1);\r\n        \r\n        if (result!=0)\r\n            cnt++;\r\n        else \r\n            cnt--;\r\n    }\r\n    if (n==1) return 1;\r\n    //子問題是  1.到底是自己(return n)或是由小的k個binary組成(return n-k)  1.變成binary會有幾位(求K)\r\n    //   ccc or ccab  => 333 or 3312\r\n    \r\n    \r\n    if(result!=0) \r\n    if(cnt==1) return n;   \r\n    else return n-k;\r\n    \r\n}\r\n*/\r\n\r\n","compare_result":null,"title_slug":"longest-palindrome","has_notes":false,"flag_type":1}