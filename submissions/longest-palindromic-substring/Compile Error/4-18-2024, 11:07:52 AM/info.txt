{"id":1235380207,"question_id":5,"lang":"java","lang_name":"Java","time":"1 month, 3 weeks","timestamp":1713409672,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1235380207/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"N/A","code":"class Solution {\n\n    public String preProcess(String s) {\n        int n = s.length();\n        if (n == 0) {\n            return \"^$\";\n        }\n        String ret = \"^\";\n        for (int i = 0; i < n; i++)\n            ret += \"#\" + s.charAt(i);\n        ret += \"#$\";\n        return ret;\n    }\n\n// s = b a b a d\n//     0 1 2 3 4 5 7 8 9 10 11\n// T = ^ b # a # b # a #  d  $\n//     C\n//     R\n//       i=1  R<=i : P[1] = 0, if(i + P[i] > R), update C and R\n//       C=i\n//       R=i + P[i]\n\n//         i=2  R<=i : P[2] = 0, if(i + P[i] > R), update C and R\n//         C=2\n//         R=2\n\n//           i=3  R<=i : P[3] = 0, expand \n// idx=0 1 2 3 4 5 7 8 9 10 11\n// T = ^ b # a # b # a #  d  $\n// P = 0 0 0 2 0 0 x x x  x  x     if(i + P[i] > R), update C and R\n//           C=i\n//               R=i+P[3]\n\n//        mi=2 i=4 R>i : P[4] = Math.min(5-4, P[mirror_i]), // mirror_i = 2*C-i => 2*3-4 => 2\n\n\n\n\n    // 马拉车算法 Manacher's algo : O(n)\n    public String longestPalindrome(String s) {\n\n        String T = preProcess(s);\n        int n = T.length();\n        int[] P = new int[n]; // record the longest Palindrome ans\n        int C = 0, R = 0;\n\n        // start from 1 skip to T.charAt(0)=='^', \n        // end before n-1 to skip T.charAt(n-1)=='$'\n        for (int i = 1; i < n - 1; i++) { \n            int mirror_i = 2 * C - i;\n            if (R > i) {\n                P[i] = Math.min(R - i, P[i_mirror]);// 防止超出 R\n            } else {\n                P[i] = 0;// 等于 R 的情况\n            }\n\n            // 碰到之前讲的三种情况时候，需要利用中心扩展法\n            while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {\n                P[i]++;\n            }\n\n            // 判断是否需要更新 R\n            if (i + P[i] > R) {\n                C = i;\n                R = i + P[i];\n            }\n\n        }\n\n        // 找出 P 的最大值\n        int maxLen = 0;\n        int centerIndex = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (P[i] > maxLen) {\n                maxLen = P[i];\n                centerIndex = i;\n            }\n        }\n        int start = (centerIndex - maxLen) / 2; //最开始讲的求原字符串下标\n        return s.substring(start, start + maxLen);\n    }\n\n\n\n    // expand O(n^2)\n    // public String longestPalindrome(String s) {\n        \n    //     int len = s.length();\n    //     String res = s.charAt(0)+\"\";\n\n    //     for(int i=0; i<len; i++){\n\n    //         String odd = expand(s, i, i);\n    //         if(odd.length()>res.length()){\n    //             res = odd;\n    //         }\n\n    //         if(i+1<len){\n    //             String even = expand(s, i, i+1);\n    //             if(even.length()>res.length()){\n    //                 res = even;   \n    //             }\n    //         }\n    //     }\n\n    //     return res;\n\n    // }\n    // private String expand(String s , int i, int j){\n        \n    //     while(i>=0 && j<s.length() && s.charAt(i)==s.charAt(j)){\n    //         i--; \n    //         j++;\n    //     }\n\n    //     i++;\n    //     j--;\n\n    //     return s.substring(i, j+1);\n    // }\n\n\n// brute-force : O(n^2)\n\n // public String longestPalindrome(String s) {\n        // String res = s.charAt(0)+\"\";\n\n        // for(int i=0; i<len; i++){\n\n        //     for(int j=i+2; j<=len; j++){\n        //         String sub = s.substring(i, j);\n        //         if(sub.length()<res.length()) continue;\n        //         if(isPal(sub)){\n        //             res = sub;\n        //         }\n        //     }\n            \n        // }\n\n        // return res;\n    // }\n\n    private boolean isPal(String s){\n        int len = s.length();\n\n        for(int i=0; i<len/2; i++){\n\n            int j = len-i-1;\n\n            if(s.charAt(i)!=s.charAt(j))\n                return false;\n        }   \n\n        return true;\n    }\n}","compare_result":null,"title_slug":"longest-palindromic-substring","has_notes":false,"flag_type":1}