{"id":830514057,"question_id":30,"lang":"java","lang_name":"Java","time":"1 year, 7 months","timestamp":1666767072,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/830514057/","is_pending":"Not Pending","title":"Substring with Concatenation of All Words","memory":"N/A","code":"class Solution {\n    \n    boolean[] seen;\n    \n    public List<Integer> findSubstring(String s, String[] words) {\n        List<String> cons = new ArrayList<>();\n        seen = new boolean[words.length];\n        dfs(words, cons, \"\");\n        \n        Set<Integer> res =new TreeSet<>();\n        for(String con : cons){\n            int idx = s.indexOf(con);\n            while(idx>=0){\n                res.add(idx);  \n                idx = s.indexOf(con, idx+1);\n            }\n        }\n        \n        return new ArrayList<>(res);\n        \n    }\n    \n    private void dfs(String[] words, List<String> cons, String curr){\n        \n        \n        // if(curr.length()>0)\n        //     cons.add(curr);\n        \n        if(curr.length()==words[0].length() * words.length){\n            cons.add(curr);\n            return;\n        }\n        \n        for(int i =0; i<words.length;i++){\n            if(seen[i]==false){\n                seen[i]=true;\n                dfs(words, cons, curr+words[i]);\n                seen[i]=false;    \n            }\n        }\n        \n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000","title_slug":"substring-with-concatenation-of-all-words","has_notes":false,"flag_type":1}