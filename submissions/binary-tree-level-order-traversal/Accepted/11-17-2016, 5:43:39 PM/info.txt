{"id":82929326,"question_id":102,"lang":"c","lang_name":"C","time":"7 years, 6 months","timestamp":1479375819,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/82929326/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"N/A","code":"/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     struct TreeNode *left;\r\n *     struct TreeNode *right;\r\n * };\r\n */\r\n/**\r\n * Return an array of arrays of size *returnSize.\r\n * The sizes of the arrays are returned as *columnSizes array.\r\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\r\n\r\n \r\n //BFS tree 太複雜 直接看CODE  QQ  //https://discuss.leetcode.com/topic/63844/c-3ms-easy-undestanding-one-queue\r\nint** levelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {\r\n    \r\n    int *arr = malloc((*returnSize+1)*sizeof(int));\r\n    \r\n    for(int i=0;i<returnSize; i++)\r\n    {\r\n         for(int j=0;j<i+1;j++)\r\n         {\r\n             //arr[i] = root[j];\r\n             i++;\r\n             \r\n         }\r\n    }\r\n    return arr;\r\n}\r\n */\r\ntypedef struct TreeNode TreeNode;\r\nint** levelOrder(struct TreeNode* root, int** columnSizes, int* returnSize) {\r\n    if (root == NULL) return NULL;\r\n    \r\n    int **ans = malloc(sizeof(int *) * 1000);\r\n    *columnSizes = malloc(sizeof(int) * 1000);\r\n    \r\n    TreeNode *queue[2000]; //easy queue\r\n    int first = 0, end = 0;\r\n    queue[end++] = root;\r\n    \r\n    int nodes_cur_level = 1, nodes_next_level = 0, level = 0;\r\n    \r\n    while (first < end) {\r\n        ans[level] = malloc( 1000 * sizeof(int) );\r\n        for (int i = 0; i < nodes_cur_level && first < end; i++) {\r\n            printf(\"first=%d end=%d cur=%d \\r\\n\",first , end, nodes_cur_level);\r\n            TreeNode *tmp = queue[first++];\r\n            ans[level][i] = tmp->val;\r\n            \r\n            if (tmp->left) {\r\n                queue[end++] = tmp->left;\r\n                nodes_next_level++;\r\n            }\r\n            if (tmp->right) {\r\n                queue[end++] = tmp->right;\r\n                nodes_next_level++;\r\n            }\r\n        }\r\n        \r\n        (*columnSizes)[level++] = nodes_cur_level;\r\n        if ((nodes_cur_level = nodes_next_level) == 0) break;\r\n        \r\n        nodes_next_level = 0;\r\n    }\r\n    \r\n    *returnSize = level;\r\n    return ans;\r\n}","compare_result":null,"title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1}