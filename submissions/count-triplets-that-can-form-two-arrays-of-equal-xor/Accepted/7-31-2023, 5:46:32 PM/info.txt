{"id":1008375426,"question_id":1553,"lang":"java","lang_name":"Java","time":"10 months, 2 weeks","timestamp":1690796792,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1008375426/","is_pending":"Not Pending","title":"Count Triplets That Can Form Two Arrays of Equal XOR","memory":"41.4 MB","code":"class Solution {\n    public int countTriplets(int[] arr) {\n        \n        int len = arr.length;\n        \n        int[] prexor = new int[len];\n        \n        HashMap<Integer, List<Integer>> map = new HashMap<>(); // val, List<idx>\n        map.put(0, new ArrayList<>());\n        map.get(0).add(-1);\n        \n        int xorsum = 0;\n        int ret = 0;\n        for (int k=0; k<arr.length; k++)\n        {\n            xorsum ^= arr[k];\n            for (int i: map.getOrDefault(xorsum, new ArrayList<>()))\n                ret+=k-(i+2)+1;\n            \n            // XX X [ X X X X X X ][X X X X]  XXX\n            //    i  i+1                    k\n            \n            // xor==0 = prexor[k] ^ prexor[i-1]\n            // ==>  prexor[i-1]==prexor[k] ^ 0\n            \n            //[i+1: k] xor==0\n            // j : [i+2: k] => k-(i+2)-1 == k-i-1;\n            \n            map.putIfAbsent(xorsum, new ArrayList<>());\n            map.get(xorsum).add(k);\n        }\n        return ret;\n        \n        //  unordered_map<int,vector<int>>Map;\n        // Map[0].push_back(-1);\n        // int xorsum = 0;\n        // int ret = 0;\n        // for (int k=0; k<arr.size(); k++)\n        // {\n        //     xorsum ^= arr[k];\n        //     for (int i: Map[xorsum])\n        //         ret += max(0, k - i -1);\n        //     Map[xorsum].push_back(k);\n        // }\n        // return ret;\n        \n        \n        \n        \n        \n        \n// // XXX   [ X X X X X X ][X X X X]  XXX\n//       // a=i^  ...^ j-1, j ... k\n        \n//         // find arr where xor ==0;\n        \n//         int len = arr.length;\n        \n//         int res = 0;\n        \n//         for(int i=0; i<len; i++){\n            \n//             int xor = arr[i];\n            \n//             for(int j=i+1; j<len; j++){\n                \n//                 xor ^= arr[j];\n//                 if(xor==0){\n//                     res+= (j-i);// 總共有(j-i+1)個element, 切成多份且每份不為0個element有幾種切法？ => (j-i)種\n//                 }\n//             }\n//         }\n        \n//         return res;\n        \n        \n    }\n}","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"count-triplets-that-can-form-two-arrays-of-equal-xor","has_notes":false,"flag_type":1}