{"id":1189470640,"question_id":351,"lang":"java","lang_name":"Java","time":"3 months, 2 weeks","timestamp":1709192567,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1189470640/","is_pending":"Not Pending","title":"Android Unlock Patterns","memory":"39.9 MB","code":"public class Solution {\n    \n    public int numberOfPatterns(int m, int n) {\n        // Skip array represents number to skip between two pairs\n        int skip[][] = new int[10][10];\n        skip[1][3] = skip[3][1] = 2;\n        skip[1][7] = skip[7][1] = 4;\n        skip[3][9] = skip[9][3] = 6;\n        skip[7][9] = skip[9][7] = 8;\n        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;\n        boolean seen[] = new boolean[10];\n        int res = 0;\n        // DFS search each length from m to n\n        for(int i = m; i <= n; ++i) {\n            res += DFS(seen, skip, 1, i - 1) * 4;    // 1, 3, 7, 9 are symmetric\n            res += DFS(seen, skip, 2, i - 1) * 4;    // 2, 4, 6, 8 are symmetric\n            res += DFS(seen, skip, 5, i - 1);        // 5\n        }\n        return res;\n    }\n\n\n    // cur: the current position\n    // remain: the steps remaining\n    private int DFS(boolean seen[], int[][] skip, int cur, int remain) {\n        if(remain < 0) return 0;\n        if(remain == 0) return 1;\n        seen[cur] = true;\n        int res = 0;\n        for(int i = 1; i <= 9; ++i) {\n            // If is not visited and (two numbers are adjacent or skip number is already visited)\n            if(!seen[i] && (skip[cur][i] == 0 || (seen[skip[cur][i]]))) {\n                res += DFS(seen, skip, i, remain - 1);\n            }\n        }\n        seen[cur] = false;\n        return res;\n    }\n    \n}","compare_result":"111111111111111111111111","title_slug":"android-unlock-patterns","has_notes":false,"flag_type":1}