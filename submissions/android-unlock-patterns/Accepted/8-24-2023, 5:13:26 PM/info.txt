{"id":1030338788,"question_id":351,"lang":"java","lang_name":"Java","time":"9 months, 3 weeks","timestamp":1692868406,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1030338788/","is_pending":"Not Pending","title":"Android Unlock Patterns","memory":"39.4 MB","code":"public class Solution {\n    // cur: the current position\n    // remain: the steps remaining\n    int DFS(boolean vis[], int[][] skip, int cur, int remain) {\n        if(remain < 0) return 0;\n        if(remain == 0) return 1;\n        vis[cur] = true;\n        int rst = 0;\n        for(int i = 1; i <= 9; ++i) {\n            // If vis[i] is not visited and (two numbers are adjacent or skip number is already visited)\n            if(!vis[i] && (skip[cur][i] == 0 || (vis[skip[cur][i]]))) {\n                rst += DFS(vis, skip, i, remain - 1);\n            }\n        }\n        vis[cur] = false;\n        return rst;\n    }\n    \n    public int numberOfPatterns(int m, int n) {\n        // Skip array represents number to skip between two pairs\n        int skip[][] = new int[10][10];\n        skip[1][3] = skip[3][1] = 2;\n        skip[1][7] = skip[7][1] = 4;\n        skip[3][9] = skip[9][3] = 6;\n        skip[7][9] = skip[9][7] = 8;\n        skip[1][9] = skip[9][1] = skip[2][8] = skip[8][2] = skip[3][7] = skip[7][3] = skip[4][6] = skip[6][4] = 5;\n        boolean vis[] = new boolean[10];\n        int rst = 0;\n        // DFS search each length from m to n\n        for(int i = m; i <= n; ++i) {\n            rst += DFS(vis, skip, 1, i - 1) * 4;    // 1, 3, 7, 9 are symmetric\n            rst += DFS(vis, skip, 2, i - 1) * 4;    // 2, 4, 6, 8 are symmetric\n            rst += DFS(vis, skip, 5, i - 1);        // 5\n        }\n        return rst;\n    }\n}","compare_result":"111111111111111111111111","title_slug":"android-unlock-patterns","has_notes":false,"flag_type":1}