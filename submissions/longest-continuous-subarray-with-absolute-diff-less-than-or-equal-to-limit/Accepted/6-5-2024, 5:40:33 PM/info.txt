{"id":1278315406,"question_id":1549,"lang":"java","lang_name":"Java","time":"1 week","timestamp":1717580433,"status":10,"status_display":"Accepted","runtime":"27 ms","url":"/submissions/detail/1278315406/","is_pending":"Not Pending","title":"Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit","memory":"56.3 MB","code":"class Solution {\n    public int longestSubarray(int[] nums, int limit) {\n        \n        // // 1. TreeMap : O(NlgN)\n        // int len = nums.length;\n        // TreeMap<Integer, Integer> map = new TreeMap<>(); // val, cnt\n        // int max = 0;\n        // int st = 0;\n        // for(int ed=0; ed<len; ed++){\n\n        //     map.put(nums[ed], map.getOrDefault(nums[ed],0)+1);\n\n        //     while(map.lastKey()-map.firstKey()>limit){\n        //         map.put(nums[st], map.get(nums[st])-1);\n        //         if(map.get(nums[st])==0) map.remove(nums[st]);\n        //         st++;\n        //     }\n\n        //     max = Math.max(max, ed-st+1);\n        // }\n\n        // return max==0 ? -1 : max;\n\n        // //2. 找最大值跟最小值 直接想到mono stack (deque) O(N)\n        int len = nums.length;\n        Deque<int[]> dq_max = new ArrayDeque<>(); // idx, val => desc\n        Deque<int[]> dq_min = new ArrayDeque<>(); //\n        int max = 0;\n        int st = 0;\n        int ed= 0;\n\n        for(; ed<len; ed++){\n            int num = nums[ed];\n\n            while(!dq_max.isEmpty() && dq_max.peekLast()[1] <=num){\n                dq_max.pollLast();\n            }\n\n            while(!dq_min.isEmpty() && dq_min.peekLast()[1] >= num){\n                dq_min.pollLast();\n            }\n            \n            dq_max.offer(new int[]{ed, num});\n            dq_min.offer(new int[]{ed, num});\n\n            if(dq_max.peek()[1] - dq_min.peek()[1]>limit){\n                if(st == dq_max.peek()[0]) dq_max.poll();\n                if(st == dq_min.peek()[0]) dq_min.poll();\n                st++;\n            }\n            max = Math.max(max, ed-st+1);\n\n        }\n        // return ed-st;\n        return max==0 ? -1 : max;\n\n\n\n\n\n\n\n\n        // //2. 找最大值跟最小值 直接想到mono stack (deque) O(N)\n        // int len = nums.length;\n        // Deque<Integer> dq_max = new ArrayDeque<>(); // idx => asc\n        // Deque<Integer> dq_min = new ArrayDeque<>(); // idx\n        // int st = 0, ed=0;\n\n        // for(; ed<len; ed++){\n        //     int n = nums[ed];\n\n        //     while(!dq_max.isEmpty() && nums[dq_max.peekLast()]<n){\n        //         dq_max.pollLast();\n        //     }\n\n        //     while(!dq_min.isEmpty() && nums[dq_min.peekLast()]>n){\n        //         dq_min.pollLast();\n        //     }\n            \n        //     dq_min.offer(ed);\n        //     dq_max.offer(ed);\n\n        //     //超過limit的話, 把min or max拉出來\n        //     //看st 是在那一個 dq內\n        //     if(nums[dq_max.peek()] - nums[dq_min.peek()]>limit){\n        //         if(nums[st] == nums[dq_max.peek()]) dq_max.poll();\n        //         if(nums[st] == nums[dq_min.peek()]) dq_min.poll();\n        //         st++;\n        //     }\n\n        // }\n\n        // return ed-st;\n\n\n\n        \n\n        // // //1. 找最大值跟最小值 : sliding window + treemap O(NlgN)\n        // int len = nums.length;\n        // TreeMap<Integer, Integer> map = new TreeMap<>(); // val, cnt\n        // map.put(nums[0], 1);        \n        // int max = 0;\n\n        // int ed= 0;\n\n        // for(int st=0; st<len; st++){\n            \n        //     while(map.lastKey() - map.firstKey()<=limit){\n        //         max = Math.max(max, ed-st+1);\n        //         ed++;\n        //         if(ed<len) map.put(nums[ed], map.getOrDefault(nums[ed],0)+1);\n        //         else break;\n        //     }\n\n        //     if(ed==len) break;\n\n        //     map.put(nums[st], map.get(nums[st])-1);\n        //     if(map.get(nums[st])==0) map.remove(nums[st]);\n        // }\n\n        // return max;\n\n\n\n        \n        // int st = 0, ed;\n        // for (ed = 0; ed < len; ed++) {\n        //     map.put(nums[ed], 1 + map.getOrDefault(nums[ed], 0));\n\n        //     if (map.lastKey() - map.firstKey() > limit) {\n        //         map.put(nums[st], map.get(nums[st]) - 1);\n        //         if (map.get(nums[st]) == 0)\n        //             map.remove(nums[st]);\n        //         st++;\n        //     }\n        // }\n        // return ed-st;\n\n\n        \n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","has_notes":false,"flag_type":1}