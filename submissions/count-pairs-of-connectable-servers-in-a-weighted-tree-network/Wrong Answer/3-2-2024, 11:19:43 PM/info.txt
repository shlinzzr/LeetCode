{"id":1191684859,"question_id":3326,"lang":"java","lang_name":"Java","time":"3 months, 1 week","timestamp":1709392783,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1191684859/","is_pending":"Not Pending","title":"Count Pairs of Connectable Servers in a Weighted Tree Network","memory":"N/A","code":"class Solution {\n    public int[] countPairsOfConnectableServers(int[][] edges, int signalSpeed) {\n        \n        int len = edges.length+1;\n        \n        int[] count= new int[len];\n        \n        \n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\n        \n        for(int[] e : edges){\n            \n            int a = e[0];\n            int b = e[1];\n            int w = e[2];\n            \n            map.putIfAbsent(a, new HashMap<>());\n            map.get(a).put(b, w);\n            \n            map.putIfAbsent(b, new HashMap<>());\n            map.get(b).put(a, w);\n        }\n        \n        \n        \n        for(int c=0; c<=len; c++){\n            \n            \n            int curr = 0;\n            \n            \n            Set<Integer> seen = new HashSet<>();\n            seen.add(c);\n            \n            if(map.get(c)==null || map.get(c).size()<=1) continue;\n            for(int neb : map.get(c).keySet()){\n                \n                int cnt=0;\n                \n                if(map.get(c).get(neb)%signalSpeed==0)\n                    cnt++;\n                \n                seen.add(neb);\n                Queue<int[]> q = new LinkedList<>();\n                q.offer(new int[]{neb, map.get(c).get(neb)}); // dest , weight\n                \n                while(q.size()>0){\n                    \n                    int[] pp = q.poll();\n                    \n                    int p = pp[0];\n                    int weight = pp[1];\n                    \n                    for(int next : map.get(p).keySet()){\n                        \n                        \n                        int w = map.get(p).get(next);\n                        \n                        if(seen.contains(next))\n                            continue;\n                        seen.add(next);\n                        q.offer(new int[]{next, weight+w});\n                        \n                        if( (weight+w)%signalSpeed==0)\n                            cnt++;\n                    }\n                }\n                \n                // System.out.println(\"neb=\"+neb + \" cnt=\"+cnt);\n                \n                if(curr==0){\n                    curr = cnt;\n                }else{\n                    curr*=cnt;\n                }\n                \n                \n            }\n            \n            count[c] = curr;\n        }\n        \n        return count;\n        \n        \n        \n        \n    \n    }\n}","compare_result":"11011010001110000010110100101100101110010011110011001111101100000111101100100010011100100100011010000000100000100111011110101100010010000110110111101111010010000110001000011010011010010100100110010100101000011001010010100011100011000110000010000000101100110011000011000001000010000010001110001001011100110100101110001101100100001010110111100111110000101011001111101010000101110001101001010011110110000111011001010110001011010000011111000001000101111100001000010111000101000000111010000110101110100001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001","title_slug":"count-pairs-of-connectable-servers-in-a-weighted-tree-network","has_notes":false,"flag_type":1}