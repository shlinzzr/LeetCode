{"id":1049785608,"question_id":1101,"lang":"java","lang_name":"Java","time":"9Â months","timestamp":1694746739,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1049785608/","is_pending":"Not Pending","title":"Parallel Courses","memory":"45.1 MB","code":"class Solution {\n    public int minimumSemesters(int N, int[][] relations) {\n        Map<Integer, List<Integer>> g = new HashMap<>(); // key: prerequisite, value: course list. \n        int[] inDegree = new int[N + 1]; // inDegree[i]: number of prerequisites for i.\n        for (int[] r : relations) {\n            g.computeIfAbsent(r[0], l -> new ArrayList<>()).add(r[1]); // construct graph.\n            ++inDegree[r[1]]; // count prerequisites for r[1].\n        }\n        Queue<Integer> q = new LinkedList<>(); // save current 0 in-degree vertices.\n        for (int i = 1; i <= N; ++i)\n            if (inDegree[i] == 0)\n                q.offer(i);\n        int semester = 0;\n        while (!q.isEmpty()) { // BFS traverse all currently 0 in degree vertices.\n            for (int sz = q.size(); sz > 0; --sz) { // sz is the search breadth.\n                int c = q.poll();\n                --N;\n                if (!g.containsKey(c)) continue; // c's in-degree is currently 0, but it has no prerequisite.\n                for (int course : g.remove(c))\n                    if (--inDegree[course] == 0) // decrease the in-degree of course's neighbors.\n                        q.offer(course); // add current 0 in-degree vertex into Queue.\n            }\n            ++semester; // need one more semester.\n        }\n        return N == 0 ? semester : -1;\n    }\n}","compare_result":"111111111111111111111111111111111111111","title_slug":"parallel-courses","has_notes":false,"flag_type":1}