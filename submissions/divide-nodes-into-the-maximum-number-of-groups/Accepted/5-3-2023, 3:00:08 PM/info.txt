{"id":943663069,"question_id":2583,"lang":"java","lang_name":"Java","time":"1 year, 1 month","timestamp":1683097208,"status":10,"status_display":"Accepted","runtime":"2099 ms","url":"/submissions/detail/943663069/","is_pending":"Not Pending","title":"Divide Nodes Into the Maximum Number of Groups","memory":"48.3 MB","code":"class Solution {\n    public int magnificentSets(int n, int[][] edges) {\n        \n        \n        UnionFind uf = new UnionFind(n);\n        \n        List<List<Integer>> adjList = new ArrayList<>();\n        for(int i = 0; i <= n; i++) \n            adjList.add(new ArrayList<>());\n\n        for(int [] edge : edges){\n            adjList.get(edge[0]).add(edge[1]);\n            adjList.get(edge[1]).add(edge[0]);\n            uf.merge(edge[0], edge[1]);\n        }\n\n        for(int i = 1; i <= n; i++){\n            Queue<Integer> q = new LinkedList<>();\n            q.add(i);\n            \n            Set<Integer> visited = new HashSet<>();\n            int counter = 0;\n            while(!q.isEmpty()){\n                int size = q.size();\n                Set<Integer> inQueue = new HashSet<>();\n                \n                for(int j = 0; j < size; j++){\n                    int p = q.poll();\n                    if(visited.contains(p)) \n                        continue;\n                    \n                    inQueue.add(p);\n                    visited.add(p);\n                    \n                    for(int neighbor : adjList.get(p)){\n                        if(inQueue.contains(neighbor)){\n                            return -1;\n                        }\n                        if(!visited.contains(neighbor))\n                            q.add(neighbor);\n                    }\n                }\n                counter++;\n            }\n            int root = uf.find(i);\n            uf.groupSize[root] = Math.max(uf.groupSize[root], counter);\n\n        }\n        \n        Set<Integer> done = new HashSet<>();\n        int result = 0;\n        for(int i = 1; i <= n; i++) {\n            int root = uf.find(i);\n            if(done.contains(root)) \n                continue;\n            done.add(root);\n            result += uf.groupSize[root];\n        }\n        return result;\n\n    }\n\n    class UnionFind {\n        int [] parent, groupSize, weight;\n\n        public UnionFind(int n){\n            this.parent = new int [n+1];\n            this.groupSize = new int [n+1];\n            this.weight = new int [n+1];\n            for(int i = 0; i < n; i++) {\n                parent[i] = i;\n                groupSize[i] = -1;\n            }\n        }\n\n        public int find(int x){\n            if(parent[x] == x) return x;\n            return parent[x] = find(parent[x]);\n        }\n\n        public void merge(int x, int y){\n\n            int rx = find(x), ry = find(y);\n\n            if(weight[rx] == weight[ry]){\n                parent[rx] = parent[ry];\n                weight[ry]++;\n            } else if(weight[rx] > weight[ry]){\n                parent[ry] = parent[rx];\n            } else parent[rx] = parent[ry];\n\n            groupSize[ry] = Math.max(groupSize[ry],  groupSize[rx]);\n            groupSize[rx] = groupSize[ry];\n        }\n\n    }\n    \n}","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"divide-nodes-into-the-maximum-number-of-groups","has_notes":false,"flag_type":1}