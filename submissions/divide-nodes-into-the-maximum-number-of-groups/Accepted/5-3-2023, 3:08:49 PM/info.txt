{"id":943666765,"question_id":2583,"lang":"java","lang_name":"Java","time":"1 year, 1 month","timestamp":1683097729,"status":10,"status_display":"Accepted","runtime":"1930 ms","url":"/submissions/detail/943666765/","is_pending":"Not Pending","title":"Divide Nodes Into the Maximum Number of Groups","memory":"50.7 MB","code":"class Solution {\n    public int magnificentSets(int n, int[][] edges) {\n        \n        UnionFind uf = new UnionFind(n);\n        \n        List<List<Integer>> adj = new ArrayList<>();\n        for(int i=0; i<=n; i++){\n            adj.add(new ArrayList<>());\n        }\n        \n        for(int[] e : edges){\n            adj.get(e[0]).add(e[1]);\n            adj.get(e[1]).add(e[0]);\n            uf.merge(e[0], e[1]);\n        }\n        \n        \n        for(int i=1; i<=n; i++){\n            HashSet<Integer> visited = new HashSet<>();\n            Queue<Integer> q = new LinkedList<>();\n            q.offer(i);\n            int step=0;\n            \n            while(!q.isEmpty()){\n                \n                HashSet<Integer> curr = new HashSet<>(); // this round bfs's root\n                \n                int siz = q.size();\n                for(int j=0; j<siz; j++){\n\n                    int p = q.poll();\n                    if(visited.contains(p))\n                        continue;// 已走過adjList, 不走adjList了\n\n                    visited.add(p);\n                    curr.add(p);    \n                    // System.out.print(step  + \" p=\" + p + \" : \");\n                    for(int next : adj.get(p)){\n                        if(curr.contains(next)) // 此次bfs parent&parent間有連通=> 死了\n                            return -1;\n\n                        if(!visited.contains(next))\n                            q.offer(next);\n                    }\n                }\n                step++;\n            }\n            \n            \n            int root = uf.find(i);\n            uf.groupSize[root] = Math.max(uf.groupSize[root], step);\n            \n            System.out.println(i + \" root=\"+root + \" groupSize=\" + uf.groupSize[root]);\n        }\n        \n        \n        Set<Integer> done = new HashSet<>();\n        int result = 0;\n        for(int i = 1; i <= n; i++) {\n            int root = uf.find(i);\n            if(done.contains(root)) \n                continue;\n            done.add(root);\n            result += uf.groupSize[root];\n        }\n        return result;\n        \n    }\n    \n    \n    \nclass UnionFind {\n        int [] parent, groupSize, weight;\n\n        public UnionFind(int n){\n            this.parent = new int [n+1];\n            this.groupSize = new int [n+1];\n            this.weight = new int [n+1];\n            for(int i = 0; i < n; i++) {\n                parent[i] = i;\n                groupSize[i] = -1;\n            }\n        }\n\n        public int find(int x){\n            if(parent[x] == x) return x;\n            return parent[x] = find(parent[x]);\n        }\n\n        public void merge(int x, int y){\n\n            int rx = find(x), ry = find(y);\n\n            if(rx==ry)\n                return;\n            \n            if(weight[rx] == weight[ry]){\n                parent[rx] = parent[ry];\n                weight[ry]++;\n                \n            } else if(weight[rx] > weight[ry]){\n                parent[ry] = parent[rx];\n                \n            } else { // weight[rx]<weight[ry]\n                parent[rx] = parent[ry];\n                groupSize[ry] = Math.max(groupSize[ry],  groupSize[rx]);\n                groupSize[rx] = groupSize[ry];\n            }\n        }\n\n    }\n}","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"divide-nodes-into-the-maximum-number-of-groups","has_notes":false,"flag_type":1}