{"id":922932169,"question_id":1485,"lang":"java","lang_name":"Java","time":"1 year, 2 months","timestamp":1679911072,"status":10,"status_display":"Accepted","runtime":"23 ms","url":"/submissions/detail/922932169/","is_pending":"Not Pending","title":"Minimum Cost to Make at Least One Valid Path in a Grid","memory":"42.5 MB","code":"class Solution {\n    int[][] DIR = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    \n    public int minCost(int[][] grid) {\n        \n        int m = grid.length, n = grid[0].length;\n        PriorityQueue<int[]> q = new PriorityQueue<>((o1, o2) -> o1[0] - o2[0]); // cost, row, col\n        q.offer(new int[]{0, 0, 0});\n        \n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; i++) \n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        \n        dist[0][0] = 0;\n        \n        while (!q.isEmpty()) {\n            int[] top = q.poll();\n            int cost = top[0], r = top[1], c = top[2];\n            \n            if (dist[r][c] < cost) \n                continue; // avoid outdated (dist[r,c], r, c) to traverse neighbors again!\n            \n            for (int i = 0; i < 4; i++) {\n                int nr = r + DIR[i][0], nc = c + DIR[i][1];\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n) {\n                    int ncost = cost;\n                    if (i != (grid[r][c] - 1)) ncost += 1; // change direction -> ncost = cost + 1\n                    if ( ncost < dist[nr][nc]) {\n                        dist[nr][nc] = ncost;\n                        q.offer(new int[]{ncost, nr, nc});\n                    }\n                }\n            }\n        }\n        return dist[m - 1][n - 1];\n    }\n}\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-to-make-at-least-one-valid-path-in-a-grid","has_notes":false,"flag_type":1}