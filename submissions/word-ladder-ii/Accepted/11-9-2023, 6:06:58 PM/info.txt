{"id":1095129326,"question_id":126,"lang":"java","lang_name":"Java","time":"7Â months","timestamp":1699524418,"status":10,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/1095129326/","is_pending":"Not Pending","title":"Word Ladder II","memory":"42.2 MB","code":"class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        List<List<String>> ans = new ArrayList<>(); \n        Map<String, Set<String>> reverse = new HashMap<>(); // reverse graph start from endWord\n        Set<String> wordSet = new HashSet<>(wordList); // remove the duplicate words\n        wordSet.remove(beginWord); // remove the first word to avoid cycle path\n        Queue<String> queue = new LinkedList<>(); // store current layer nodes\n        queue.add(beginWord); // first layer has only beginWord\n        Set<String> nextLevel = new HashSet<>(); // store nextLayer nodes\n        boolean findEnd = false; // find endWord flag\n        while (!queue.isEmpty()) { // traverse current layer nodes\n            String word = queue.poll();\n            for (String next : wordSet) {\n                if (isLadder(word, next)) { // is ladder words\n\t\t\t\t\t// construct the reverse graph from endWord\n\n                    reverse.putIfAbsent(next, new HashSet<>());\n                    Set<String> reverseLadders = reverse.get(next);\n                    reverseLadders.add(word); \n                    if (endWord.equals(next)) {\n                        findEnd = true;\n                    }\n                    nextLevel.add(next); // store next layer nodes\n                }\n            }\n            if (queue.isEmpty()) { // when current layer is all visited\n                if (findEnd) break; // if find the endWord, then break the while loop\n                queue.addAll(nextLevel); // add next layer nodes to queue\n                wordSet.removeAll(nextLevel); // remove all next layer nodes in wordSet\n                nextLevel.clear();\n            }\n        }\n        if (!findEnd) return ans; // if can't reach endWord from startWord, then return ans.\n        Set<String> path = new LinkedHashSet<>();\n        path.add(endWord);\n\t\t// traverse reverse graph from endWord to beginWord\n        findPath(endWord, beginWord, reverse, ans, path); \n        return ans;\n    }\n\n\n    private void findPath(String endWord, String beginWord, Map<String, Set<String>> graph,\n                                 List<List<String>> ans, Set<String> path) {\n        Set<String> next = graph.get(endWord);\n        if (next == null) return;\n        for (String word : next) {\n            path.add(word);\n            if (beginWord.equals(word)) {\n                List<String> shortestPath = new ArrayList<>(path);\n                Collections.reverse(shortestPath); // reverse words in shortest path\n                ans.add(shortestPath); // add the shortest path to ans.\n            } else {\n                findPath(word, beginWord, graph, ans, path);\n            }\n            path.remove(word);\n        }\n    }\n\n    private boolean isLadder(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int diffCount = 0;\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != t.charAt(i)) diffCount++;\n            if (diffCount > 1) return false;\n        }\n        return diffCount == 1;\n    }\n}","compare_result":"111111111111111111111111111111111111","title_slug":"word-ladder-ii","has_notes":false,"flag_type":1}