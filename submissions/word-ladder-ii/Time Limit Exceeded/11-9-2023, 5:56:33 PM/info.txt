{"id":1095124433,"question_id":126,"lang":"java","lang_name":"Java","time":"7Â months","timestamp":1699523793,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1095124433/","is_pending":"Not Pending","title":"Word Ladder II","memory":"N/A","code":"class Solution {\n    public List<List<String>> findLadders(String start, String end, List<String> wordList) {\n        HashSet<String> dict = new HashSet<String>(wordList);\n        List<List<String>> res = new ArrayList<List<String>>();         \n        HashMap<String, ArrayList<String>> nodeNeighbors = new HashMap<String, ArrayList<String>>();// Neighbors for every node\n        HashMap<String, Integer> distance = new HashMap<String, Integer>();// Distance of every node from the start node\n        ArrayList<String> solution = new ArrayList<String>();\n\n        dict.add(start);          \n        bfs(start, end, dict, nodeNeighbors, distance);                 \n        dfs(start, end, dict, nodeNeighbors, distance, solution, res);   \n        return res;\n    }\n\n// BFS: Trace every node's distance from the start node (level by level).\n    private void bfs(String start, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance) {\n    for (String str : dict)\n        nodeNeighbors.put(str, new ArrayList<String>());\n\n    Queue<String> queue = new LinkedList<String>();\n    queue.offer(start);\n    distance.put(start, 0);\n\n    while (!queue.isEmpty()) {\n        int count = queue.size();\n        boolean foundEnd = false;\n        for (int i = 0; i < count; i++) {\n            String cur = queue.poll();\n            int curDistance = distance.get(cur);                \n            ArrayList<String> neighbors = getNeighbors(cur, dict);\n\n            for (String neighbor : neighbors) {\n                nodeNeighbors.get(cur).add(neighbor);\n                if (!distance.containsKey(neighbor)) {// Check if visited\n                    distance.put(neighbor, curDistance + 1);\n                    if (end.equals(neighbor))// Found the shortest path\n                        foundEnd = true;\n                    else\n                        queue.offer(neighbor);\n                    }\n                }\n            }\n\n            if (foundEnd)\n                break;\n        }\n    }\n\n    // Find all next level nodes.    \n    private ArrayList<String> getNeighbors(String node, Set<String> dict) {\n    ArrayList<String> res = new ArrayList<String>();\n    char chs[] = node.toCharArray();\n\n    for (char ch ='a'; ch <= 'z'; ch++) {\n        for (int i = 0; i < chs.length; i++) {\n            if (chs[i] == ch) continue;\n            char old_ch = chs[i];\n            chs[i] = ch;\n            if (dict.contains(String.valueOf(chs))) {\n                res.add(String.valueOf(chs));\n            }\n            chs[i] = old_ch;\n        }\n\n    }\n    return res;\n    }\n\n    // DFS: output all paths with the shortest distance.\n    private void dfs(String cur, String end, Set<String> dict, HashMap<String, ArrayList<String>> nodeNeighbors, HashMap<String, Integer> distance, ArrayList<String> solution, List<List<String>> res) {\n        solution.add(cur);\n        if (end.equals(cur)) {\n        res.add(new ArrayList<String>(solution));\n        } else {\n        for (String next : nodeNeighbors.get(cur)) {            \n                if (distance.get(next) == distance.get(cur) + 1) {\n                    dfs(next, end, dict, nodeNeighbors, distance, solution, res);\n                }\n            }\n        }           \n    solution.remove(solution.size() - 1);\n    }\n}","compare_result":"111111111111111111111111111111110000","title_slug":"word-ladder-ii","has_notes":false,"flag_type":1}