{"id":1099212701,"question_id":255,"lang":"java","lang_name":"Java","time":"7Â months","timestamp":1700031162,"status":10,"status_display":"Accepted","runtime":"165 ms","url":"/submissions/detail/1099212701/","is_pending":"Not Pending","title":"Verify Preorder Sequence in Binary Search Tree","memory":"45 MB","code":"class Solution {\n    public boolean verifyPreorder(int[] preorder) {\n\n        Stack<Integer> st = new Stack<>();\n        int base = Integer.MIN_VALUE;\n\n        for (int i=0; i<preorder.length; i++)\n        {\n            if (preorder[i]<base) \n                return false;\n            \n            while (!st.isEmpty() && st.peek()<preorder[i]){\n                base = st.pop();\n                System.out.println(preorder[i] + \" \" +base);\n            }\n            st.push(preorder[i]);              \n        }\n        return true;\n\n        /*. recursive\n        int len = preorder.length;\n\n        if(len<2) return true;\n\n        int root = preorder[0];\n\n\n        int i=1;\n        while(i<len && preorder[i]<root){\n            i++;\n        }\n\n        for(int j=i; j<len; j++){\n            if(preorder[j]<root)\n                return false;\n        }\n\n        boolean left = (i-1<1) ? true : verifyPreorder(Arrays.copyOfRange(preorder, 1, i));  // [1, i)\n        boolean right = i+1>len ? true :  verifyPreorder(Arrays.copyOfRange(preorder, i, len)); // [i, len-1)\n\n        return left && right;\n        */\n\n\n    }\n\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111","title_slug":"verify-preorder-sequence-in-binary-search-tree","has_notes":false,"flag_type":1}